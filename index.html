<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ImbalanceChart v5 â€” Engine Edition</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg: #0a0e17;
    --bg-panel: #111827;
    --bg-card: #0d1321;
    --border: #1e293b;
    --border-active: #334155;
    --text: #94a3b8;
    --text-strong: #e2e8f0;
    --text-dim: #475569;
    --bull: #00e676;
    --bear: #ff1744;
    --highlight: #ffd740;
    --accent: #ff6b35;
    --grid: #1e293b;
    --grid-strong: #334155;
    --crosshair: #64748b;
    --absorption-buy: #00e676;
    --absorption-sell: #ff5252;
  }

  body {
    font-family: 'JetBrains Mono', monospace;
    background: var(--bg);
    color: var(--text);
    overflow: hidden;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }

  /* ===== HEADER ===== */
  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 12px;
    background: var(--bg-panel);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .header-left { display: flex; align-items: center; gap: 12px; }
  .header h1 {
    font-size: 14px;
    font-weight: 600;
    color: var(--bull);
    letter-spacing: -0.3px;
  }
  .header h1 span { color: var(--accent); }

  .status-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 2px 8px;
    border-radius: 3px;
    font-size: 9px;
    font-weight: 600;
    letter-spacing: 0.5px;
  }
  .status-badge.connected { background: #22c55e15; border: 1px solid #22c55e44; color: var(--bull); }
  .status-badge.disconnected { background: #ef444415; border: 1px solid #ef444444; color: var(--bear); }
  .status-badge.binance { background: #f59e0b15; border: 1px solid #f59e0b44; color: var(--highlight); }

  .price-display {
    font-size: 18px;
    font-weight: 700;
    color: var(--text-strong);
    font-variant-numeric: tabular-nums;
  }
  .price-display.up { color: var(--bull); }
  .price-display.down { color: var(--bear); }

  /* ===== CONTROLS BAR ===== */
  .controls {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 4px 12px;
    background: var(--bg-panel);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
    flex-wrap: wrap;
  }
  .ctrl-group {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .ctrl-label {
    font-size: 9px;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .ctrl-value {
    font-size: 11px;
    color: var(--highlight);
    font-weight: 600;
    min-width: 45px;
  }
  input[type="range"] {
    width: 90px;
    height: 3px;
    accent-color: var(--highlight);
    cursor: pointer;
  }
  .btn {
    padding: 3px 10px;
    background: transparent;
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--text);
    font-family: inherit;
    font-size: 10px;
    cursor: pointer;
    transition: all 0.15s;
  }
  .btn:hover { border-color: var(--highlight); color: var(--text-strong); }
  .btn.active { background: var(--highlight); color: var(--bg); border-color: var(--highlight); }
  .btn.live { background: var(--bull); color: #fff; border-color: var(--bull); font-weight: 700; }
  .btn.live.stopped { background: var(--bear); border-color: var(--bear); }
  .btn.accent { background: var(--accent); color: #fff; border-color: var(--accent); }

  /* ===== ENGINE PANEL ===== */
  .engine-panel {
    display: none;
    padding: 6px 12px;
    background: var(--bg-card);
    border-bottom: 1px solid #ff6b3533;
    flex-shrink: 0;
  }
  .engine-panel.visible { display: block; }
  .engine-panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }
  .engine-panel-header span {
    font-size: 10px;
    font-weight: 600;
    color: var(--accent);
  }
  .engine-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
    gap: 6px;
  }
  .engine-card {
    background: var(--bg);
    border-radius: 4px;
    padding: 6px 8px;
    border: 1px solid var(--border);
  }
  .engine-card-title {
    font-size: 8px;
    color: var(--highlight);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 3px;
  }
  .engine-card-value {
    font-size: 11px;
    color: var(--text-strong);
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .engine-card-value .dim { color: var(--text-dim); font-size: 9px; }
  .engine-card-value .bull { color: var(--absorption-buy); }
  .engine-card-value .bear { color: var(--absorption-sell); }
  .engine-card-value .burst { color: var(--accent); font-weight: 700; }

  /* ===== FORMING CLUSTER STATUS ===== */
  .forming-bar {
    display: none;
    padding: 4px 12px;
    background: var(--bg-panel);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
    align-items: center;
    gap: 12px;
    font-size: 10px;
  }
  .forming-bar.visible { display: flex; }
  .delta-bar-bg {
    width: 80px;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    overflow: hidden;
  }
  .delta-bar-fill {
    height: 100%;
    border-radius: 2px;
    transition: width 0.1s;
  }

  /* ===== CHART AREA ===== */
  .chart-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    min-height: 0;
  }
  #chart {
    display: block;
    cursor: crosshair;
  }

  /* ===== LEGEND OVERLAY ===== */
  .legend {
    position: absolute;
    bottom: 8px;
    left: 8px;
    display: flex;
    gap: 10px;
    font-size: 8px;
    opacity: 0.6;
    pointer-events: none;
  }
  .legend-item { display: flex; align-items: center; gap: 3px; }
  .legend-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
  }
</style>
</head>
<body>

<!-- HEADER -->
<div class="header">
  <div class="header-left">
    <h1>ðŸ“Š Imbalance Chart <span>v5</span> â€” Engine Edition</h1>
    <span class="status-badge disconnected" id="wsStatus">â¬¤ DESCONECTADO</span>
    <span class="status-badge binance" id="binanceStatus" style="display:none">â¬¤ BINANCE</span>
  </div>
  <div style="display:flex;align-items:center;gap:12px;">
    <span class="price-display" id="priceDisplay">--</span>
    <span style="font-size:10px;color:var(--text-dim)" id="tickCounter">0 ticks</span>
  </div>
</div>

<!-- CONTROLS -->
<div class="controls">
  <div class="ctrl-group">
    <span class="ctrl-label">Î” Threshold</span>
    <input type="range" id="thresholdSlider" min="1000" max="500000" value="50000" step="1000">
    <span class="ctrl-value" id="thresholdValue">50k</span>
  </div>
  <div class="ctrl-group">
    <span class="ctrl-label">Price Step</span>
    <input type="range" id="stepSlider" min="0" max="100" value="10" step="1">
    <span class="ctrl-value" id="stepValue">$10</span>
  </div>
  <div class="ctrl-group">
    <span class="ctrl-label">Modo</span>
    <button class="btn active" data-mode="hybrid" onclick="setViewMode('hybrid')">Hybrid</button>
    <button class="btn" data-mode="clean" onclick="setViewMode('clean')">Clean</button>
    <button class="btn" data-mode="raw" onclick="setViewMode('raw')">Raw</button>
  </div>
  <div class="ctrl-group">
    <button class="btn accent" id="engineToggle" onclick="toggleEnginePanel()">ðŸ”¥ Engines</button>
    <button class="btn live" id="liveBtn" onclick="toggleLive()">â–¶ LIVE</button>
    <button class="btn" onclick="resetChart()">â†º Reset</button>
  </div>
  <div class="ctrl-group" style="margin-left:auto">
    <span class="ctrl-label">Clusters:</span>
    <span class="ctrl-value" id="clusterCount" style="color:var(--text-strong)">0</span>
  </div>
</div>

<!-- ENGINE PANEL -->
<div class="engine-panel" id="enginePanel">
  <div class="engine-panel-header">
    <span>ðŸ”¥ Engine Analysis â€” Real-time</span>
    <span style="font-size:9px;color:var(--text-dim)">Fonte: Binance BTC/USDT</span>
  </div>
  <div class="engine-grid">
    <div class="engine-card">
      <div class="engine-card-title">âš¡ Tick Velocity</div>
      <div class="engine-card-value">
        <span id="eng_velocity">-- t/s</span>
        <span class="dim">base: <span id="eng_velocity_base">--</span></span>
        <span class="burst" id="eng_burst" style="display:none">ðŸ”¥ BURST</span>
      </div>
    </div>
    <div class="engine-card">
      <div class="engine-card-title">ðŸ§© Micro AbsorÃ§Ã£o</div>
      <div class="engine-card-value">
        <span id="eng_absorption">Sem absorÃ§Ã£o</span>
        <span class="dim">Total: <span id="eng_abs_total">0</span></span>
      </div>
    </div>
    <div class="engine-card">
      <div class="engine-card-title">ðŸ“Š ATR (5s Candles)</div>
      <div class="engine-card-value">
        <span id="eng_atr">--</span>
        <span id="eng_atr_regime" class="dim">warmup</span>
      </div>
    </div>
    <div class="engine-card">
      <div class="engine-card-title">ðŸ”¥ Imbalance Stacking</div>
      <div class="engine-card-value">
        <span class="bull" id="eng_stack_buy">Buy: S0</span>
        <span class="bear" id="eng_stack_sell">Sell: S0</span>
        <span id="eng_dominant" style="font-weight:700"></span>
      </div>
    </div>
    <div class="engine-card">
      <div class="engine-card-title">ðŸ“‰ Volatilidade</div>
      <div class="engine-card-value">
        <span id="eng_vol">-- bps</span>
        <span id="eng_vol_regime" class="dim">--</span>
      </div>
    </div>
    <div class="engine-card">
      <div class="engine-card-title">ðŸ“¡ Sinal Composto</div>
      <div class="engine-card-value">
        <span id="eng_signal" style="font-size:14px;font-weight:700">0%</span>
        <span class="dim" id="eng_signal_label">neutro</span>
      </div>
    </div>
  </div>
</div>

<!-- FORMING CLUSTER STATUS -->
<div class="forming-bar" id="formingBar">
  <span style="color:var(--highlight)">ðŸ”„ Formando</span>
  <span>Î”: <strong id="formingDelta" style="font-variant-numeric:tabular-nums">0</strong></span>
  <span style="color:var(--text-dim)">Body: <span id="formingBody">0%</span> | Wick: <span id="formingWick">0%</span></span>
  <span id="formingAbsorptions" style="color:var(--accent);display:none"></span>
  <span id="formingStacking" style="display:none"></span>
  <div class="delta-bar-bg">
    <div class="delta-bar-fill" id="deltaBarFill"></div>
  </div>
</div>

<!-- CHART -->
<div class="chart-container" id="chartContainer">
  <canvas id="chart"></canvas>
  <div class="legend">
    <div class="legend-item"><div class="legend-dot" style="background:var(--absorption-buy)"></div> Buy AbsorÃ§Ã£o</div>
    <div class="legend-item"><div class="legend-dot" style="background:var(--absorption-sell)"></div> Sell AbsorÃ§Ã£o</div>
    <div class="legend-item"><div class="legend-dot" style="background:var(--highlight)"></div> Wick &gt;50%</div>
  </div>
</div>

<script>
// ====================================================================
// IMBALANCECHART v5 â€” ENGINE EDITION (Standalone Frontend)
// ====================================================================

// ---------- CONFIG ----------
const CONFIG = {
  bg: '#0a0e17',
  bgPanel: '#111827',
  bull: '#00e676',
  bear: '#ff1744',
  bullDark: '#004d40',
  bearDark: '#4a0000',
  bullBody: '#00c853',
  bearBody: '#d50000',
  highlight: '#ffd740',
  accent: '#ff6b35',
  grid: '#1a2332',
  gridStrong: '#2a3a4d',
  text: '#8899aa',
  textStrong: '#e2e8f0',
  crosshair: '#546e7a',
  absorptionBuy: '#00e676',
  absorptionSell: '#ff5252',
  clusterGap: 4,
  histogramBullColor: '#00e676',
  histogramBearColor: '#ff1744',
  histogramOpacity: 85,
  wickWarningThreshold: 50,
  pocColor: '#ffd740',
  currentPriceColor: '#00bcd4',
};

const WS_URL = 'ws://localhost:8765';
const PRICE_WIDTH = 80;
const HISTOGRAM_RATIO = 0.25; // 25% da altura para histograma (bem evidente)

// ---------- STATE ----------
let ws = null;
let isLive = false;
let allTicks = [];
let clusters = [];
let threshold = 50000;
let priceStep = 10.0; // $10 para BTC
let viewMode = 'hybrid'; // clean | hybrid | raw
let showEnginePanel = true;
let lastPrice = 0;
let lastSide = 'buy';
let totalTicks = 0;
let engineState = {};

// View state
let viewState = {
  offsetX: 0,
  offsetY: 0,
  scaleX: 1,
  scaleY: 1,
  isDragging: false,
  lastX: 0,
  lastY: 0,
};

// Crosshair
let crosshair = { x: 0, y: 0, visible: false };

// Canvas
let canvas, ctx;
let chartW, chartH, histH, totalH;

// ---------- INITIALIZATION ----------
function init() {
  canvas = document.getElementById('chart');
  ctx = canvas.getContext('2d');
  resize();
  window.addEventListener('resize', resize);
  setupCanvasEvents();
  setupControls();
  render();
  // Auto-connect
  toggleLive();
}

function resize() {
  const container = document.getElementById('chartContainer');
  const w = container.clientWidth;
  const h = container.clientHeight;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  totalH = h;
  histH = Math.floor(h * HISTOGRAM_RATIO);
  chartH = h - histH;
  chartW = w - PRICE_WIDTH;
  render();
}

// ---------- WEBSOCKET ----------
function connectWS() {
  if (ws && ws.readyState <= 1) return;
  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    document.getElementById('wsStatus').className = 'status-badge connected';
    document.getElementById('wsStatus').textContent = 'â¬¤ WS CONECTADO';
    ws.send(JSON.stringify({ type: 'subscribe', symbol: 'btcusdt' }));
  };

  ws.onmessage = (e) => {
    try {
      const msg = JSON.parse(e.data);
      if (msg.type === 'tick') {
        processTick(msg.data);
      } else if (msg.type === 'connected') {
        const isBinance = msg.data?.mt5_connected || msg.data?.source === 'binance';
        const badge = document.getElementById('binanceStatus');
        if (isBinance) {
          badge.style.display = 'inline-flex';
          badge.textContent = 'â¬¤ BINANCE LIVE';
        }
      }
    } catch(err) {}
  };

  ws.onclose = () => {
    document.getElementById('wsStatus').className = 'status-badge disconnected';
    document.getElementById('wsStatus').textContent = 'â¬¤ DESCONECTADO';
    document.getElementById('binanceStatus').style.display = 'none';
    if (isLive) setTimeout(connectWS, 3000);
  };

  ws.onerror = () => ws.close();
}

function disconnectWS() {
  if (ws) { ws.close(); ws = null; }
  document.getElementById('wsStatus').className = 'status-badge disconnected';
  document.getElementById('wsStatus').textContent = 'â¬¤ DESCONECTADO';
  document.getElementById('binanceStatus').style.display = 'none';
}

// ---------- TICK PROCESSING ----------
function processTick(data) {
  const tick = {
    price: data.price,
    volume: Math.round(data.volume_synthetic || 1),
    side: data.side || 'buy',
    timestamp: data.timestamp || Date.now(),
    is_absorption: data.is_absorption || false,
    absorption_type: data.absorption_type || null,
    absorption_strength: data.absorption_strength || 0,
    composite_signal: data.composite_signal || 0,
    stacking_buy: data.stacking_buy || 0,
    stacking_sell: data.stacking_sell || 0,
  };

  lastPrice = tick.price;
  lastSide = tick.side;
  totalTicks++;

  allTicks.push(tick);
  if (allTicks.length > 15000) allTicks = allTicks.slice(-10000);

  // Update engine state
  if (data.engines) {
    engineState = data.engines;
    updateEnginePanel();
  }

  // Rebuild clusters
  reprocessClusters();
  updateUI();
  render();
}

// ---------- CLUSTER FORMATION (Delta-based atemporal) ----------
function reprocessClusters() {
  clusters = [];
  let current = null;
  let clusterId = 0;

  for (const tick of allTicks) {
    const vol = tick.volume;
    const discretePrice = priceStep > 0
      ? Math.round(tick.price / priceStep) * priceStep
      : tick.price;

    // Check if we need to close current cluster
    if (current && Math.abs(current.delta) >= threshold) {
      current.isClosed = true;
      current.endTime = tick.timestamp;
      clusters.push(current);
      current = null;
    }

    if (!current) {
      // Create new cluster
      const priceLevels = priceStep > 0
        ? [{ price: discretePrice, volumeBuy: tick.side === 'buy' ? vol : 0, volumeSell: tick.side === 'sell' ? vol : 0, volumeTotal: vol }]
        : [];

      current = {
        id: clusterId++,
        open: discretePrice,
        high: discretePrice,
        low: discretePrice,
        close: discretePrice,
        volumeBuy: tick.side === 'buy' ? vol : 0,
        volumeSell: tick.side === 'sell' ? vol : 0,
        volumeTotal: vol,
        volumeBody: vol,
        volumeWick: 0,
        wickPercent: 0,
        delta: tick.side === 'buy' ? vol : -vol,
        tickCount: 1,
        startTime: tick.timestamp,
        isClosed: false,
        poc: discretePrice,
        priceLevels: priceLevels,
        // Engine aggregates
        absorptionCount: tick.is_absorption ? 1 : 0,
        absorptionBuyCount: tick.absorption_type === 'buy_absorption' ? 1 : 0,
        absorptionSellCount: tick.absorption_type === 'sell_absorption' ? 1 : 0,
        maxAbsorptionStrength: tick.absorption_strength || 0,
        maxStackingBuy: tick.stacking_buy || 0,
        maxStackingSell: tick.stacking_sell || 0,
        compositeSignalAvg: tick.composite_signal || 0,
      };
      continue;
    }

    // Update existing cluster
    current.close = discretePrice;
    current.high = Math.max(current.high, discretePrice);
    current.low = Math.min(current.low, discretePrice);
    current.volumeTotal += vol;
    current.tickCount++;

    // Body/Wick volume
    const bodyHigh = Math.max(current.open, current.close);
    const bodyLow = Math.min(current.open, current.close);
    if (discretePrice >= bodyLow && discretePrice <= bodyHigh) {
      current.volumeBody += vol;
    } else {
      current.volumeWick += vol;
    }
    current.wickPercent = current.volumeTotal > 0 ? (current.volumeWick / current.volumeTotal) * 100 : 0;

    // Delta
    if (tick.side === 'buy') {
      current.volumeBuy += vol;
      current.delta += vol;
    } else {
      current.volumeSell += vol;
      current.delta -= vol;
    }

    // Price levels (footprint)
    if (priceStep > 0) {
      const existing = current.priceLevels.find(l => l.price === discretePrice);
      if (existing) {
        if (tick.side === 'buy') existing.volumeBuy += vol;
        else existing.volumeSell += vol;
        existing.volumeTotal += vol;
      } else {
        current.priceLevels.push({
          price: discretePrice,
          volumeBuy: tick.side === 'buy' ? vol : 0,
          volumeSell: tick.side === 'sell' ? vol : 0,
          volumeTotal: vol,
        });
      }
      // Update POC
      let maxVol = 0;
      for (const l of current.priceLevels) {
        if (l.volumeTotal > maxVol) {
          maxVol = l.volumeTotal;
          current.poc = l.price;
        }
      }
    }

    // Engine aggregates
    if (tick.is_absorption) {
      current.absorptionCount++;
      if (tick.absorption_type === 'buy_absorption') current.absorptionBuyCount++;
      if (tick.absorption_type === 'sell_absorption') current.absorptionSellCount++;
      current.maxAbsorptionStrength = Math.max(current.maxAbsorptionStrength, tick.absorption_strength || 0);
    }
    current.maxStackingBuy = Math.max(current.maxStackingBuy, tick.stacking_buy || 0);
    current.maxStackingSell = Math.max(current.maxStackingSell, tick.stacking_sell || 0);
    const n = current.tickCount;
    current.compositeSignalAvg = (current.compositeSignalAvg * (n - 1) + (tick.composite_signal || 0)) / n;
  }

  // Add forming cluster
  if (current) clusters.push(current);

  // Auto-scroll to end
  const clusterWidth = Math.max(8, 40 * viewState.scaleX);
  const totalWidth = clusters.length * (clusterWidth + CONFIG.clusterGap);
  const maxOffset = Math.max(0, totalWidth - chartW);
  viewState.offsetX = -maxOffset;
}

// ---------- RENDERING ----------
function render() {
  if (!ctx) return;
  const w = canvas.width / (window.devicePixelRatio || 1);
  const h = canvas.height / (window.devicePixelRatio || 1);

  ctx.fillStyle = CONFIG.bg;
  ctx.fillRect(0, 0, w, h);

  if (clusters.length === 0) {
    ctx.fillStyle = CONFIG.text;
    ctx.font = '14px JetBrains Mono';
    ctx.textAlign = 'center';
    ctx.fillText('Aguardando ticks da Binance...', w / 2, h / 2 - 10);
    ctx.font = '11px JetBrains Mono';
    ctx.fillStyle = CONFIG.crosshair;
    ctx.fillText('Clique â–¶ LIVE para conectar', w / 2, h / 2 + 12);
    return;
  }

  const clusterWidth = Math.max(8, 40 * viewState.scaleX);

  // Price range
  let priceHigh = -Infinity, priceLow = Infinity;
  for (const c of clusters) {
    priceHigh = Math.max(priceHigh, c.high);
    priceLow = Math.min(priceLow, c.low);
  }
  const range = (priceHigh - priceLow) * viewState.scaleY;
  const center = (priceHigh + priceLow) / 2;
  const pad = range * 0.15;
  const viewHigh = center + range / 2 + pad;
  const viewLow = center - range / 2 - pad;

  // Price conversions
  const priceToY = (p) => ((viewHigh - p) / (viewHigh - viewLow)) * chartH;
  const yToPrice = (y) => viewHigh - (y / chartH) * (viewHigh - viewLow);
  const clusterToX = (i) => viewState.offsetX + i * (clusterWidth + CONFIG.clusterGap) + clusterWidth / 2;

  // Max volume
  let maxVolume = 1;
  for (const c of clusters) maxVolume = Math.max(maxVolume, c.volumeTotal);

  // ========== GRID ==========
  ctx.lineWidth = 0.5;
  const gridLines = 10;
  const gridStep = (viewHigh - viewLow) / gridLines;
  for (let i = 0; i <= gridLines; i++) {
    const y = (chartH / gridLines) * i;
    const price = viewHigh - gridStep * i;

    // Alternate stronger lines
    ctx.strokeStyle = i % 2 === 0 ? CONFIG.gridStrong + '66' : CONFIG.grid + '44';
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(chartW, y);
    ctx.stroke();

    // Price label
    ctx.fillStyle = CONFIG.text;
    ctx.font = '9px JetBrains Mono';
    ctx.textAlign = 'left';
    ctx.fillText(price.toFixed(2), chartW + 5, y + 3);
  }

  // Price scale separator
  ctx.strokeStyle = CONFIG.gridStrong;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(chartW, 0);
  ctx.lineTo(chartW, totalH);
  ctx.stroke();

  // ========== CURRENT PRICE LINE ==========
  if (lastPrice > 0 && lastPrice >= viewLow && lastPrice <= viewHigh) {
    const cpY = priceToY(lastPrice);
    ctx.strokeStyle = CONFIG.currentPriceColor;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([8, 4]);
    ctx.beginPath();
    ctx.moveTo(0, cpY);
    ctx.lineTo(chartW, cpY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Price label box on right
    ctx.fillStyle = CONFIG.currentPriceColor;
    ctx.fillRect(chartW + 1, cpY - 10, PRICE_WIDTH - 6, 20);
    ctx.fillStyle = '#000';
    ctx.font = 'bold 10px JetBrains Mono';
    ctx.textAlign = 'left';
    ctx.fillText('$' + lastPrice.toFixed(2), chartW + 4, cpY + 4);

    // Small arrow
    ctx.fillStyle = CONFIG.currentPriceColor;
    ctx.beginPath();
    ctx.moveTo(chartW, cpY);
    ctx.lineTo(chartW - 6, cpY - 5);
    ctx.lineTo(chartW - 6, cpY + 5);
    ctx.closePath();
    ctx.fill();
  }

  // ========== CLUSTERS ==========
  for (let idx = 0; idx < clusters.length; idx++) {
    const cluster = clusters[idx];
    const centerX = clusterToX(idx);
    const x = centerX - clusterWidth / 2;
    const cw = clusterWidth;

    if (centerX < -cw || centerX > chartW + cw) continue;

    const isBull = cluster.close >= cluster.open;
    const deltaIntensity = Math.min(1, Math.abs(cluster.delta) / (threshold * 0.8));

    // ===== WICK LINE =====
    const highY = priceToY(cluster.high);
    const lowY = priceToY(cluster.low);
    ctx.strokeStyle = isBull ? CONFIG.bull + 'aa' : CONFIG.bear + 'aa';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(centerX, highY);
    ctx.lineTo(centerX, lowY);
    ctx.stroke();

    // ===== BODY =====
    const bodyTop = priceToY(Math.max(cluster.open, cluster.close));
    const bodyBottom = priceToY(Math.min(cluster.open, cluster.close));
    const bodyH = Math.max(3, bodyBottom - bodyTop);

    // Body fill with gradient based on delta intensity
    const alphaHex = Math.round(40 + deltaIntensity * 180).toString(16).padStart(2, '0');
    const borderAlpha = Math.round(120 + deltaIntensity * 135).toString(16).padStart(2, '0');

    if (viewMode === 'clean') {
      // Solid fill with intensity
      ctx.fillStyle = isBull ? CONFIG.bullBody + alphaHex : CONFIG.bearBody + alphaHex;
      ctx.fillRect(x, bodyTop, cw, bodyH);
    } else {
      // Gradient fill
      const grad = ctx.createLinearGradient(x, bodyTop, x, bodyTop + bodyH);
      if (isBull) {
        grad.addColorStop(0, CONFIG.bull + alphaHex);
        grad.addColorStop(0.5, CONFIG.bullBody + Math.round(60 + deltaIntensity * 160).toString(16).padStart(2, '0'));
        grad.addColorStop(1, CONFIG.bullDark + alphaHex);
      } else {
        grad.addColorStop(0, CONFIG.bearDark + alphaHex);
        grad.addColorStop(0.5, CONFIG.bearBody + Math.round(60 + deltaIntensity * 160).toString(16).padStart(2, '0'));
        grad.addColorStop(1, CONFIG.bear + alphaHex);
      }
      ctx.fillStyle = grad;
      ctx.fillRect(x, bodyTop, cw, bodyH);
    }

    // Body border
    ctx.strokeStyle = isBull ? CONFIG.bull + borderAlpha : CONFIG.bear + borderAlpha;
    ctx.lineWidth = 1.5;
    ctx.strokeRect(x, bodyTop, cw, bodyH);

    // Delta label inside body (when zoomed enough)
    if (viewState.scaleX >= 0.9 && bodyH > 14) {
      ctx.fillStyle = isBull ? '#ffffff' + borderAlpha : '#ffffff' + borderAlpha;
      ctx.font = 'bold 8px JetBrains Mono';
      ctx.textAlign = 'center';
      const deltaText = (cluster.delta >= 0 ? '+' : '') + (Math.abs(cluster.delta) >= 1000 ? (cluster.delta / 1000).toFixed(1) + 'k' : cluster.delta);
      ctx.fillText(deltaText, centerX, bodyTop + bodyH / 2 + 3);
    }

    // ===== POC LINE (VERY EVIDENT) =====
    if (cluster.priceLevels.length > 0) {
      const pocY = priceToY(cluster.poc);

      // Glow effect (3 layers)
      ctx.strokeStyle = CONFIG.pocColor + '22';
      ctx.lineWidth = 7;
      ctx.beginPath();
      ctx.moveTo(x - 6, pocY);
      ctx.lineTo(x + cw + 6, pocY);
      ctx.stroke();

      ctx.strokeStyle = CONFIG.pocColor + '55';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x - 5, pocY);
      ctx.lineTo(x + cw + 5, pocY);
      ctx.stroke();

      ctx.strokeStyle = CONFIG.pocColor;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x - 4, pocY);
      ctx.lineTo(x + cw + 4, pocY);
      ctx.stroke();

      // POC diamond marker
      ctx.fillStyle = CONFIG.pocColor;
      ctx.beginPath();
      ctx.moveTo(x - 6, pocY);
      ctx.lineTo(x - 3, pocY - 3);
      ctx.lineTo(x, pocY);
      ctx.lineTo(x - 3, pocY + 3);
      ctx.closePath();
      ctx.fill();

      // POC price label (when zoomed)
      if (viewState.scaleX >= 1.2) {
        ctx.fillStyle = CONFIG.pocColor;
        ctx.font = 'bold 7px JetBrains Mono';
        ctx.textAlign = 'center';
        ctx.fillText('POC', centerX, pocY - 5);
      }
    }

    // ========== FOOTPRINT (Hybrid / Raw) ==========
    if (viewMode !== 'clean' && cluster.priceLevels.length > 0) {
      const maxLevelVol = Math.max(...cluster.priceLevels.map(l => l.volumeTotal));
      const barRatio = viewMode === 'raw' ? 0.9 : 0.65;

      for (const level of cluster.priceLevels) {
        const ly = priceToY(level.price);
        const volRatio = level.volumeTotal / maxLevelVol;
        const barW = volRatio * cw * barRatio;

        // Colored bars with higher opacity based on volume concentration
        const levelAlpha = Math.round(80 + volRatio * 175).toString(16).padStart(2, '0');
        const isBuyDom = level.volumeBuy >= level.volumeSell;
        ctx.fillStyle = (isBuyDom ? CONFIG.histogramBullColor : CONFIG.histogramBearColor) + levelAlpha;
        ctx.fillRect(centerX - barW / 2, ly - 1.5, barW, 3);

        // Bright edge for high-volume levels
        if (volRatio > 0.7) {
          ctx.fillStyle = (isBuyDom ? '#b9f6ca' : '#ffcdd2') + '66';
          ctx.fillRect(centerX - barW / 2, ly - 0.5, barW, 1);
        }

        // Volume text on raw mode
        if (viewMode === 'raw' && viewState.scaleX >= 1.5 && level.volumeTotal > 0) {
          ctx.fillStyle = isBuyDom ? CONFIG.bull + 'cc' : CONFIG.bear + 'cc';
          ctx.font = '6px JetBrains Mono';
          ctx.textAlign = 'center';
          ctx.fillText(level.volumeTotal.toString(), centerX, ly + 6);
        }
      }
    }

    // Volume labels
    if (viewState.scaleX >= 1) {
      ctx.font = '7px JetBrains Mono';
      ctx.textAlign = 'center';
      // Wick vol
      ctx.fillStyle = '#667788';
      ctx.fillText('W:' + cluster.volumeWick, centerX, lowY + 10);
      // Body vol
      ctx.fillStyle = isBull ? CONFIG.bull + 'cc' : CONFIG.bear + 'cc';
      ctx.fillText('B:' + cluster.volumeBody, centerX, highY - 4);
    }

    // Forming cluster dashed border
    if (!cluster.isClosed) {
      ctx.strokeStyle = CONFIG.highlight;
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 3]);
      ctx.strokeRect(x - 1, bodyTop - 1, cw + 2, bodyH + 2);
      ctx.setLineDash([]);

      // Pulsing glow for forming cluster
      ctx.shadowColor = CONFIG.highlight;
      ctx.shadowBlur = 6;
      ctx.strokeStyle = CONFIG.highlight + '44';
      ctx.lineWidth = 1;
      ctx.strokeRect(x - 2, bodyTop - 2, cw + 4, bodyH + 4);
      ctx.shadowBlur = 0;
    }

    // ========== WICK WARNING ==========
    if (cluster.wickPercent >= CONFIG.wickWarningThreshold) {
      const warningY = lowY + 16;

      // Glow
      ctx.shadowColor = CONFIG.highlight;
      ctx.shadowBlur = 8;
      ctx.fillStyle = CONFIG.highlight;
      ctx.beginPath();
      ctx.arc(centerX, warningY, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Inner dot
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(centerX, warningY, 2, 0, Math.PI * 2);
      ctx.fill();

      if (viewState.scaleX >= 0.8) {
        ctx.fillStyle = CONFIG.highlight;
        ctx.font = 'bold 8px JetBrains Mono';
        ctx.textAlign = 'center';
        ctx.fillText(cluster.wickPercent.toFixed(0) + '%', centerX, warningY + 13);
      }
    }

    // ========== ENGINE OVERLAYS ==========

    // ðŸ§© Absorption markers
    if (cluster.absorptionCount > 0) {
      const ms = Math.min(6, Math.max(3, cw * 0.3));

      if (cluster.absorptionBuyCount > cluster.absorptionSellCount) {
        // Buy absorption: green triangle below
        ctx.fillStyle = CONFIG.absorptionBuy;
        ctx.beginPath();
        ctx.moveTo(centerX, lowY + ms * 3);
        ctx.lineTo(centerX - ms, lowY + ms * 3 + ms * 1.5);
        ctx.lineTo(centerX + ms, lowY + ms * 3 + ms * 1.5);
        ctx.closePath();
        ctx.fill();
        if (cluster.absorptionBuyCount > 1 && viewState.scaleX >= 0.8) {
          ctx.fillStyle = CONFIG.absorptionBuy;
          ctx.font = 'bold 7px JetBrains Mono';
          ctx.textAlign = 'center';
          ctx.fillText('' + cluster.absorptionBuyCount, centerX, lowY + ms * 3 + ms * 1.5 + 10);
        }
      } else if (cluster.absorptionSellCount > 0) {
        // Sell absorption: red triangle above
        ctx.fillStyle = CONFIG.absorptionSell;
        ctx.beginPath();
        ctx.moveTo(centerX, highY - ms * 3);
        ctx.lineTo(centerX - ms, highY - ms * 3 - ms * 1.5);
        ctx.lineTo(centerX + ms, highY - ms * 3 - ms * 1.5);
        ctx.closePath();
        ctx.fill();
        if (cluster.absorptionSellCount > 1 && viewState.scaleX >= 0.8) {
          ctx.fillStyle = CONFIG.absorptionSell;
          ctx.font = 'bold 7px JetBrains Mono';
          ctx.textAlign = 'center';
          ctx.fillText('' + cluster.absorptionSellCount, centerX, highY - ms * 3 - ms * 1.5 - 4);
        }
      }
    }

    // ðŸ”¥ Stacking bars
    if (cluster.maxStackingBuy >= 2 || cluster.maxStackingSell >= 2) {
      const barW2 = Math.max(2, cw * 0.12);
      const bTop = bodyTop;
      const bH = Math.max(4, bodyH);

      if (cluster.maxStackingBuy >= 2) {
        const intensity = Math.min(cluster.maxStackingBuy / 5, 1);
        const alpha = Math.round(intensity * 200 + 55).toString(16).padStart(2, '0');
        ctx.fillStyle = CONFIG.absorptionBuy + alpha;
        ctx.fillRect(x - barW2 - 1, bTop, barW2, bH);
        if (viewState.scaleX >= 0.8) {
          ctx.fillStyle = CONFIG.absorptionBuy;
          ctx.font = 'bold 7px JetBrains Mono';
          ctx.textAlign = 'right';
          ctx.fillText('S' + cluster.maxStackingBuy, x - barW2 - 2, bTop + bH / 2 + 3);
        }
      }
      if (cluster.maxStackingSell >= 2) {
        const intensity = Math.min(cluster.maxStackingSell / 5, 1);
        const alpha = Math.round(intensity * 200 + 55).toString(16).padStart(2, '0');
        ctx.fillStyle = CONFIG.absorptionSell + alpha;
        ctx.fillRect(x + cw + 1, bTop, barW2, bH);
        if (viewState.scaleX >= 0.8) {
          ctx.fillStyle = CONFIG.absorptionSell;
          ctx.font = 'bold 7px JetBrains Mono';
          ctx.textAlign = 'left';
          ctx.fillText('S' + cluster.maxStackingSell, x + cw + barW2 + 2, bTop + bH / 2 + 3);
        }
      }
    }

    // ðŸ“Š Composite signal dot
    if (Math.abs(cluster.compositeSignalAvg) > 0.2 && viewState.scaleX >= 0.7) {
      const dotX = x + cw - 3;
      const dotY = highY - 2;
      const dotSize = Math.min(4, 2 + Math.abs(cluster.compositeSignalAvg) * 3);
      ctx.fillStyle = cluster.compositeSignalAvg > 0 ? CONFIG.absorptionBuy + '88' : CONFIG.absorptionSell + '88';
      ctx.beginPath();
      ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // ========== VOLUME HISTOGRAM (DUAL BAR â€” VERY EVIDENT) ==========
  if (histH > 0) {
    const histY = chartH;
    const labelH = 14;
    const gap = 4;
    const availH = histH - labelH - gap;
    const bar1H = availH * 0.55; // Volume total (bigger)
    const bar2H = availH * 0.45; // Body/Wick split

    // Background with subtle gradient
    const histGrad = ctx.createLinearGradient(0, histY, 0, histY + histH);
    histGrad.addColorStop(0, '#0f1923');
    histGrad.addColorStop(1, '#0a0e17');
    ctx.fillStyle = histGrad;
    ctx.fillRect(0, histY, chartW + PRICE_WIDTH, histH);

    // Separator line (bright)
    ctx.strokeStyle = '#334455';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, histY);
    ctx.lineTo(chartW + PRICE_WIDTH, histY);
    ctx.stroke();

    // Middle separator (between bar1 and bar2)
    const midY = histY + labelH + bar1H + gap / 2;
    ctx.strokeStyle = '#1e2d3d';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(0, midY);
    ctx.lineTo(chartW, midY);
    ctx.stroke();

    // Labels
    ctx.font = 'bold 8px JetBrains Mono';
    ctx.textAlign = 'left';
    ctx.fillStyle = CONFIG.highlight;
    ctx.fillText('VOL', 4, histY + 10);
    ctx.fillStyle = '#667788';
    ctx.fillText('BODY/WICK', 4, midY + 10);

    for (let idx = 0; idx < clusters.length; idx++) {
      const cluster = clusters[idx];
      const centerX = clusterToX(idx);
      const x = centerX - clusterWidth / 2;
      if (centerX < -clusterWidth || centerX > chartW + clusterWidth) continue;

      const isBull = cluster.close >= cluster.open;
      const volRatio = cluster.volumeTotal / maxVolume;

      // ===== BAR 1: VOLUME TOTAL (top) =====
      const v1H = volRatio * (bar1H - 4);
      const v1Y = histY + labelH + bar1H - v1H;

      // Gradient bar
      const vGrad = ctx.createLinearGradient(x, v1Y, x, v1Y + v1H);
      if (isBull) {
        vGrad.addColorStop(0, CONFIG.bull);
        vGrad.addColorStop(1, CONFIG.bullDark + 'cc');
      } else {
        vGrad.addColorStop(0, CONFIG.bear);
        vGrad.addColorStop(1, CONFIG.bearDark + 'cc');
      }
      ctx.fillStyle = vGrad;
      ctx.fillRect(x + 0.5, v1Y, clusterWidth - 1, v1H);

      // Bright top edge
      ctx.fillStyle = isBull ? '#b9f6ca55' : '#ffcdd255';
      ctx.fillRect(x + 0.5, v1Y, clusterWidth - 1, Math.min(2, v1H));

      // Volume text on big bars
      if (volRatio > 0.3 && viewState.scaleX >= 0.8 && v1H > 10) {
        ctx.fillStyle = '#ffffffbb';
        ctx.font = '7px JetBrains Mono';
        ctx.textAlign = 'center';
        const vText = cluster.volumeTotal >= 1000 ? (cluster.volumeTotal / 1000).toFixed(1) + 'k' : '' + cluster.volumeTotal;
        ctx.fillText(vText, centerX, v1Y + v1H / 2 + 3);
      }

      // ===== BAR 2: BODY / WICK SPLIT (bottom) =====
      const v2H = volRatio * (bar2H - 4);
      const v2Y = midY + gap / 2;

      if (cluster.volumeTotal > 0) {
        const bodyPct = cluster.volumeBody / cluster.volumeTotal;
        const wickPct = cluster.volumeWick / cluster.volumeTotal;
        const bodyBarH = v2H * bodyPct;
        const wickBarH = v2H * wickPct;
        const baseY2 = v2Y + bar2H - v2H;

        // Wick part (bottom of bar)
        if (wickBarH > 0) {
          const wickColor = cluster.wickPercent >= 50 ? '#ffd740' : '#455a64';
          ctx.fillStyle = wickColor + 'cc';
          ctx.fillRect(x + 0.5, baseY2, clusterWidth - 1, wickBarH);
        }
        // Body part (top of bar, stacked on wick)
        if (bodyBarH > 0) {
          ctx.fillStyle = isBull ? '#4caf50cc' : '#e53935cc';
          ctx.fillRect(x + 0.5, baseY2 + wickBarH, clusterWidth - 1, bodyBarH);
        }
      }

      // Wick warning highlight at bottom
      if (cluster.wickPercent >= CONFIG.wickWarningThreshold) {
        ctx.fillStyle = CONFIG.highlight + 'aa';
        ctx.fillRect(x, histY + histH - 3, clusterWidth, 3);
      }
    }
  }

  // ========== CROSSHAIR ==========
  if (crosshair.visible) {
    ctx.strokeStyle = CONFIG.crosshair;
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);

    ctx.beginPath();
    ctx.moveTo(crosshair.x, 0);
    ctx.lineTo(crosshair.x, totalH);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0, crosshair.y);
    ctx.lineTo(chartW, crosshair.y);
    ctx.stroke();
    ctx.setLineDash([]);

    // Price label
    if (crosshair.y < chartH) {
      const price = yToPrice(crosshair.y);
      ctx.fillStyle = CONFIG.highlight;
      ctx.fillRect(chartW + 1, crosshair.y - 10, PRICE_WIDTH - 6, 20);
      ctx.fillStyle = '#000';
      ctx.font = 'bold 10px JetBrains Mono';
      ctx.textAlign = 'left';
      ctx.fillText(price.toFixed(2), chartW + 4, crosshair.y + 4);
    }
  }

  // ========== HEADER OVERLAY ==========
  ctx.fillStyle = '#0a0e17ee';
  ctx.fillRect(0, 0, 420, 34);
  ctx.fillStyle = CONFIG.highlight;
  ctx.font = 'bold 12px JetBrains Mono';
  ctx.textAlign = 'left';
  ctx.fillText(`BTC/USDT | ${viewMode.toUpperCase()} | BINANCE LIVE`, 8, 13);
  ctx.fillStyle = CONFIG.text;
  ctx.font = '9px JetBrains Mono';
  const closedCount = clusters.filter(c => c.isClosed).length;
  ctx.fillText(`Clusters: ${closedCount} | Î”: ${threshold >= 1000 ? (threshold/1000)+'k' : threshold} | Step: $${priceStep.toFixed(0)} | Zoom: ${(viewState.scaleX * 100).toFixed(0)}%`, 8, 26);

  // Legend (top right)
  ctx.fillStyle = CONFIG.bgPanel + 'dd';
  ctx.fillRect(chartW - 210, 0, 210, 28);
  ctx.font = '7px JetBrains Mono';
  ctx.textAlign = 'left';
  ctx.fillStyle = CONFIG.absorptionBuy; ctx.fillText('â–² Buy AbsorÃ§Ã£o', chartW - 205, 10);
  ctx.fillStyle = CONFIG.absorptionSell; ctx.fillText('â–¼ Sell AbsorÃ§Ã£o', chartW - 205, 20);
  ctx.fillStyle = CONFIG.absorptionBuy; ctx.fillText('â•‘ Stacking Buy', chartW - 110, 10);
  ctx.fillStyle = CONFIG.absorptionSell; ctx.fillText('â•‘ Stacking Sell', chartW - 110, 20);

  // ========== MINIMAP ==========
  if (clusters.length > 2) {
    const mmW = 100, mmH = 24;
    const mmX = chartW - mmW - 8;
    const mmY = chartH - mmH - 8;

    ctx.fillStyle = CONFIG.bgPanel;
    ctx.fillRect(mmX, mmY, mmW, mmH);
    ctx.strokeStyle = CONFIG.gridStrong;
    ctx.lineWidth = 1;
    ctx.strokeRect(mmX, mmY, mmW, mmH);

    const mmScale = mmW / clusters.length;
    for (let i = 0; i < clusters.length; i++) {
      const c = clusters[i];
      const mx = mmX + i * mmScale;
      ctx.fillStyle = (c.close >= c.open ? CONFIG.bull : CONFIG.bear) + '77';
      ctx.fillRect(mx, mmY + 2, Math.max(1, mmScale), mmH - 4);
      if (c.wickPercent >= CONFIG.wickWarningThreshold) {
        ctx.fillStyle = CONFIG.highlight + 'cc';
        ctx.fillRect(mx, mmY + mmH - 4, Math.max(1, mmScale), 3);
      }
      // Absorption marker in minimap
      if (c.absorptionCount > 0) {
        ctx.fillStyle = c.absorptionBuyCount > c.absorptionSellCount ? CONFIG.absorptionBuy + '88' : CONFIG.absorptionSell + '88';
        ctx.fillRect(mx, mmY, Math.max(1, mmScale), 3);
      }
    }

    const totalWidth = clusters.length * (clusterWidth + CONFIG.clusterGap);
    const vpW = (chartW / totalWidth) * mmW;
    const vpX = mmX + (-viewState.offsetX / totalWidth) * mmW;
    ctx.strokeStyle = CONFIG.highlight;
    ctx.lineWidth = 2;
    ctx.strokeRect(Math.max(mmX, vpX), mmY, Math.min(vpW, mmW), mmH);
  }
}

// ---------- CANVAS EVENTS ----------
function setupCanvasEvents() {
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    crosshair = { x: Math.min(x, chartW), y, visible: true };

    if (viewState.isDragging) {
      const dx = e.clientX - viewState.lastX;
      viewState.offsetX += dx;
      viewState.lastX = e.clientX;
    }
    render();
  });

  canvas.addEventListener('mouseleave', () => {
    crosshair.visible = false;
    viewState.isDragging = false;
    render();
  });

  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;

    if (x > chartW) {
      // Price scale drag â†’ vertical zoom
      viewState.isDragging = true;
      viewState.lastY = e.clientY;
      viewState.dragMode = 'zoom';
    } else {
      viewState.isDragging = true;
      viewState.lastX = e.clientX;
      viewState.dragMode = 'pan';
    }
  });

  canvas.addEventListener('mouseup', () => {
    viewState.isDragging = false;
  });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    if (e.ctrlKey) {
      // Zoom
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      viewState.scaleX = Math.max(0.2, Math.min(15, viewState.scaleX * delta));
    } else {
      // Pan
      viewState.offsetX += e.deltaY > 0 ? 50 : -50;
    }
    render();
  }, { passive: false });
}

// ---------- CONTROLS ----------
function setupControls() {
  const thSlider = document.getElementById('thresholdSlider');
  const thValue = document.getElementById('thresholdValue');
  thSlider.addEventListener('input', () => {
    threshold = Number(thSlider.value);
    thValue.textContent = threshold >= 1000 ? (threshold / 1000) + 'k' : threshold;
    reprocessClusters();
    render();
  });

  const stSlider = document.getElementById('stepSlider');
  const stValue = document.getElementById('stepValue');
  stSlider.addEventListener('input', () => {
    const val = Number(stSlider.value);
    priceStep = val === 0 ? 0 : val * 1.0; // $1 per tick â†’ val=10 = $10
    stValue.textContent = priceStep === 0 ? 'AUTO' : '$' + priceStep.toFixed(0);
    reprocessClusters();
    render();
  });
}

function setViewMode(mode) {
  viewMode = mode;
  document.querySelectorAll('[data-mode]').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.mode === mode);
  });
  render();
}

function toggleEnginePanel() {
  showEnginePanel = !showEnginePanel;
  document.getElementById('enginePanel').classList.toggle('visible', showEnginePanel);
  document.getElementById('engineToggle').classList.toggle('active', showEnginePanel);
  resize();
}

function toggleLive() {
  isLive = !isLive;
  const btn = document.getElementById('liveBtn');
  if (isLive) {
    btn.textContent = 'â¹ PARAR';
    btn.classList.add('stopped');
    connectWS();
  } else {
    btn.textContent = 'â–¶ LIVE';
    btn.classList.remove('stopped');
    disconnectWS();
  }
}

function resetChart() {
  allTicks = [];
  clusters = [];
  totalTicks = 0;
  viewState.offsetX = 0;
  viewState.scaleX = 1;
  viewState.scaleY = 1;
  updateUI();
  render();
}

// ---------- UI UPDATES ----------
function updateUI() {
  // Price display
  const priceEl = document.getElementById('priceDisplay');
  priceEl.textContent = lastPrice > 0 ? '$' + lastPrice.toFixed(2) : '--';
  priceEl.className = 'price-display ' + (lastSide === 'buy' ? 'up' : 'down');

  // Tick counter
  document.getElementById('tickCounter').textContent = totalTicks.toLocaleString() + ' ticks';

  // Cluster counter
  document.getElementById('clusterCount').textContent = clusters.filter(c => c.isClosed).length;

  // Forming cluster bar
  const forming = clusters.find(c => !c.isClosed);
  const bar = document.getElementById('formingBar');
  if (forming) {
    bar.classList.add('visible');
    const deltaEl = document.getElementById('formingDelta');
    deltaEl.textContent = (forming.delta >= 0 ? '+' : '') + forming.delta;
    deltaEl.style.color = forming.delta >= 0 ? CONFIG.bull : CONFIG.bear;

    document.getElementById('formingBody').textContent =
      forming.volumeTotal > 0 ? ((forming.volumeBody / forming.volumeTotal) * 100).toFixed(0) + '%' : '0%';
    document.getElementById('formingWick').textContent = forming.wickPercent.toFixed(0) + '%';

    // Absorption info
    const absEl = document.getElementById('formingAbsorptions');
    if (forming.absorptionCount > 0) {
      absEl.style.display = 'inline';
      absEl.textContent = `ðŸ§© ${forming.absorptionCount} abs (${forming.absorptionBuyCount}B / ${forming.absorptionSellCount}S)`;
    } else {
      absEl.style.display = 'none';
    }

    // Stacking info
    const stackEl = document.getElementById('formingStacking');
    if (forming.maxStackingBuy >= 2 || forming.maxStackingSell >= 2) {
      stackEl.style.display = 'inline';
      stackEl.style.color = forming.maxStackingBuy > forming.maxStackingSell ? CONFIG.absorptionBuy : CONFIG.absorptionSell;
      stackEl.style.fontWeight = '700';
      stackEl.textContent = `ðŸ”¥ Stack B${forming.maxStackingBuy}/S${forming.maxStackingSell}`;
    } else {
      stackEl.style.display = 'none';
    }

    // Delta progress bar
    const fill = document.getElementById('deltaBarFill');
    const pct = Math.min(100, (Math.abs(forming.delta) / threshold) * 100);
    fill.style.width = pct + '%';
    fill.style.background = forming.delta >= 0 ? CONFIG.bull : CONFIG.bear;
  } else {
    bar.classList.remove('visible');
  }
}

function updateEnginePanel() {
  const e = engineState;

  // Tick Velocity
  if (e.tick_velocity) {
    document.getElementById('eng_velocity').textContent = (e.tick_velocity.velocity || 0).toFixed(1) + ' t/s';
    document.getElementById('eng_velocity_base').textContent = (e.tick_velocity.baseline || 0).toFixed(1);
    const burst = document.getElementById('eng_burst');
    burst.style.display = e.tick_velocity.is_burst ? 'inline' : 'none';
  }

  // Micro Cluster / Absorption
  if (e.micro_cluster) {
    const absEl = document.getElementById('eng_absorption');
    if (e.micro_cluster.is_absorption) {
      const isBuy = e.micro_cluster.absorption_type === 'buy_absorption';
      absEl.textContent = isBuy ? 'ðŸŸ¢ BUY ABS' : 'ðŸ”´ SELL ABS';
      absEl.style.color = isBuy ? CONFIG.absorptionBuy : CONFIG.absorptionSell;
    } else {
      absEl.textContent = 'Sem absorÃ§Ã£o';
      absEl.style.color = CONFIG.text;
    }
    document.getElementById('eng_abs_total').textContent = e.micro_cluster.total_absorptions || 0;
  }

  // ATR
  if (e.atr_normalize) {
    const atr = e.atr_normalize.atr;
    document.getElementById('eng_atr').textContent = atr ? (atr * 100).toFixed(4) : '--';
    const regimeEl = document.getElementById('eng_atr_regime');
    regimeEl.textContent = e.atr_normalize.regime || 'warmup';
    regimeEl.style.color =
      e.atr_normalize.regime === 'expanding' ? CONFIG.absorptionSell :
      e.atr_normalize.regime === 'contracting' ? CONFIG.absorptionBuy : CONFIG.text;
  }

  // Imbalance Stacking
  if (e.imbalance_detector) {
    document.getElementById('eng_stack_buy').textContent = 'Buy: S' + (e.imbalance_detector.stacking_buy || 0);
    document.getElementById('eng_stack_sell').textContent = 'Sell: S' + (e.imbalance_detector.stacking_sell || 0);
    const dom = document.getElementById('eng_dominant');
    if (e.imbalance_detector.dominant_direction) {
      dom.textContent = 'â†’ ' + e.imbalance_detector.dominant_direction.toUpperCase();
      dom.style.color = e.imbalance_detector.dominant_direction === 'buy' ? CONFIG.absorptionBuy : CONFIG.absorptionSell;
    } else {
      dom.textContent = '';
    }
  }

  // Spread / Volatility
  if (e.spread_weight) {
    document.getElementById('eng_vol').textContent = (e.spread_weight.volatility || 0).toFixed(2) + ' bps';
    const regEl = document.getElementById('eng_vol_regime');
    regEl.textContent = e.spread_weight.regime || '--';
    regEl.style.color =
      e.spread_weight.regime === 'high' ? CONFIG.absorptionSell :
      e.spread_weight.regime === 'low' ? CONFIG.absorptionBuy : CONFIG.text;
  }

  // Composite Signal
  const signal = e.micro_cluster?.signal || 0;
  const sigEl = document.getElementById('eng_signal');
  sigEl.textContent = (signal * 100).toFixed(0) + '%';
  sigEl.style.color = signal > 0.2 ? CONFIG.absorptionBuy : signal < -0.2 ? CONFIG.absorptionSell : CONFIG.text;
  const labEl = document.getElementById('eng_signal_label');
  labEl.textContent = signal > 0 ? 'bullish' : signal < 0 ? 'bearish' : 'neutro';
}

// ---------- START ----------
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>