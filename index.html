<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ImbalanceChart v7 ‚Äî MT5 Engine Edition</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg: #0a0e17;
    --bg-panel: #111827;
    --bg-card: #0d1321;
    --border: #1e293b;
    --border-active: #334155;
    --text: #94a3b8;
    --text-strong: #e2e8f0;
    --text-dim: #475569;
    --bull: #00e676;
    --bear: #ff1744;
    --highlight: #ffd740;
    --accent: #ff6b35;
    --grid: #1e293b;
    --grid-strong: #334155;
    --crosshair: #64748b;
    --absorption-buy: #00e676;
    --absorption-sell: #ff5252;
  }

  body {
    font-family: 'JetBrains Mono', monospace;
    background: var(--bg);
    color: var(--text);
    overflow: hidden;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }

  /* ===== HEADER ===== */
  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 12px;
    background: var(--bg-panel);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .header-left { display: flex; align-items: center; gap: 12px; }
  .header h1 {
    font-size: 14px;
    font-weight: 600;
    color: var(--bull);
    letter-spacing: -0.3px;
  }
  .header h1 span { color: var(--accent); }

  .status-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 2px 8px;
    border-radius: 3px;
    font-size: 9px;
    font-weight: 600;
    letter-spacing: 0.5px;
  }
  .status-badge.connected { background: #22c55e15; border: 1px solid #22c55e44; color: var(--bull); }
  .status-badge.disconnected { background: #ef444415; border: 1px solid #ef444444; color: var(--bear); }
  .status-badge.binance { background: #f59e0b15; border: 1px solid #f59e0b44; color: var(--highlight); }

  .price-display {
    font-size: 18px;
    font-weight: 700;
    color: var(--text-strong);
    font-variant-numeric: tabular-nums;
  }
  .price-display.up { color: var(--bull); }
  .price-display.down { color: var(--bear); }

  /* ===== CONTROLS BAR ===== */
  .controls {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 4px 12px;
    background: var(--bg-panel);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
    flex-wrap: wrap;
  }
  .ctrl-group {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .ctrl-label {
    font-size: 9px;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .ctrl-value {
    font-size: 11px;
    color: var(--highlight);
    font-weight: 600;
    min-width: 45px;
  }
  input[type="range"] {
    width: 90px;
    height: 3px;
    accent-color: var(--highlight);
    cursor: pointer;
  }
  .btn {
    padding: 3px 10px;
    background: transparent;
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--text);
    font-family: inherit;
    font-size: 10px;
    cursor: pointer;
    transition: all 0.15s;
  }
  .btn:hover { border-color: var(--highlight); color: var(--text-strong); }
  .btn.active { background: var(--highlight); color: var(--bg); border-color: var(--highlight); }
  .btn.live { background: var(--bull); color: #fff; border-color: var(--bull); font-weight: 700; }
  .btn.live.stopped { background: var(--bear); border-color: var(--bear); }
  .btn.accent { background: var(--accent); color: #fff; border-color: var(--accent); }

  /* ===== ENGINE PANEL ===== */
  .engine-panel {
    display: none;
    padding: 6px 12px;
    background: var(--bg-card);
    border-bottom: 1px solid #ff6b3533;
    flex-shrink: 0;
  }
  .engine-panel.visible { display: block; }
  .engine-panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }
  .engine-panel-header span {
    font-size: 10px;
    font-weight: 600;
    color: var(--accent);
  }
  .engine-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
    gap: 6px;
  }
  .engine-card {
    background: var(--bg);
    border-radius: 4px;
    padding: 6px 8px;
    border: 1px solid var(--border);
  }
  .engine-card-title {
    font-size: 8px;
    color: var(--highlight);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 3px;
  }
  .engine-card-value {
    font-size: 11px;
    color: var(--text-strong);
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .engine-card-value .dim { color: var(--text-dim); font-size: 9px; }
  .engine-card-value .bull { color: var(--absorption-buy); }
  .engine-card-value .bear { color: var(--absorption-sell); }
  .engine-card-value .burst { color: var(--accent); font-weight: 700; }

  /* ===== FORMING CLUSTER STATUS ===== */
  .forming-bar {
    display: none;
    padding: 4px 12px;
    background: var(--bg-panel);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
    align-items: center;
    gap: 12px;
    font-size: 10px;
  }
  .forming-bar.visible { display: flex; }
  .delta-bar-bg {
    width: 80px;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    overflow: hidden;
  }
  .delta-bar-fill {
    height: 100%;
    border-radius: 2px;
    transition: width 0.1s;
  }

  /* ===== CHART AREA ===== */
  .chart-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    min-height: 0;
  }
  #chart {
    display: block;
    cursor: crosshair;
  }

  /* ===== LEGEND OVERLAY ===== */
  .legend {
    position: absolute;
    bottom: 8px;
    left: 8px;
    display: flex;
    gap: 10px;
    font-size: 8px;
    opacity: 0.6;
    pointer-events: none;
  }
  .legend-item { display: flex; align-items: center; gap: 3px; }
  .legend-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
  }
</style>
</head>
<body>

<!-- HEADER -->
<div class="header">
  <div class="header-left">
    <h1>üìä Imbalance Chart <span>v7</span> ‚Äî MT5 Engine Edition</h1>
    <span class="status-badge disconnected" id="wsStatus">‚¨§ DESCONECTADO</span>
    <span class="status-badge binance" id="binanceStatus" style="display:none">‚¨§ BINANCE</span>
  </div>
  <div style="display:flex;align-items:center;gap:12px;">
    <span class="price-display" id="priceDisplay">--</span>
    <span style="font-size:10px;color:var(--text-dim)" id="tickCounter">0 ticks</span>
  </div>
</div>

<!-- CONTROLS -->
<div class="controls">
  <div class="ctrl-group">
    <span class="ctrl-label">S√≠mbolo</span>
    <select id="symbolSelect" onchange="switchSymbol(this.value)" style="background:var(--bg);color:var(--text-strong);border:1px solid var(--border);border-radius:3px;padding:2px 6px;font-family:inherit;font-size:10px;">
      <option value="XAUUSD" selected>XAU/USD</option>
      <option value="BTCUSD">BTC/USD</option>
      <option value="USTEC">USTEC</option>
      <option value="EURUSD">EUR/USD</option>
      <option value="GBPUSD">GBP/USD</option>
    </select>
  </div>
  <div class="ctrl-group">
    <span class="ctrl-label">Œî Threshold</span>
    <input type="range" id="thresholdSlider" min="10" max="500000" value="5000" step="10">
    <span class="ctrl-value" id="thresholdValue">5k</span>
  </div>
  <div class="ctrl-group">
    <span class="ctrl-label">Price Step</span>
    <input type="range" id="stepSlider" min="0" max="100" value="5" step="1">
    <span class="ctrl-value" id="stepValue">$0.50</span>
  </div>
  <div class="ctrl-group">
    <span class="ctrl-label">Modo</span>
    <button class="btn active" data-mode="hybrid" onclick="setViewMode('hybrid')">Hybrid</button>
    <button class="btn" data-mode="clean" onclick="setViewMode('clean')">Clean</button>
    <button class="btn" data-mode="raw" onclick="setViewMode('raw')">Raw</button>
  </div>
  <div class="ctrl-group">
    <span class="ctrl-label">Hist</span>
    <button class="btn" onclick="loadHistory(1)">1h</button>
    <button class="btn" onclick="loadHistory(4)">4h</button>
    <button class="btn" onclick="loadHistory(12)">12h</button>
    <button class="btn" onclick="loadHistory(24)">24h</button>
  </div>
  <div class="ctrl-group">
    <span class="ctrl-label">‚öñÔ∏è Peso</span>
    <select id="weightSelect" onchange="setWeightMode(this.value)" style="background:var(--bg);color:var(--highlight);border:1px solid var(--border);border-radius:3px;padding:2px 6px;font-family:inherit;font-size:9px;">
      <option value="price_weighted" selected>Pre√ßo</option>
      <option value="spread_weighted">Spread</option>
      <option value="equal">Igual</option>
    </select>
  </div>
  <div class="ctrl-group">
    <button class="btn accent" id="engineToggle" onclick="toggleEnginePanel()">üî• Engines</button>
    <button class="btn" id="calibToggle" onclick="toggleCalibration()" style="border-color:#9c27b0;color:#ce93d8">‚öôÔ∏è Config</button>
  </div>
  <div class="ctrl-group">
    <span class="ctrl-label">‚úèÔ∏è Desenho</span>
    <button class="btn" data-draw="hline" onclick="setDrawTool('hline')">‚Äî H</button>
    <button class="btn" data-draw="vline" onclick="setDrawTool('vline')">| V</button>
    <button class="btn" data-draw="rect" onclick="setDrawTool('rect')">‚ñ≠</button>
    <button class="btn" data-draw="trend" onclick="setDrawTool('trend')">‚Üó</button>
    <button class="btn" onclick="setDrawTool('none')" style="color:var(--text-dim)">‚úï</button>
    <button class="btn" onclick="clearDrawings()" style="color:var(--bear)">üóë</button>
    <button class="btn live" id="liveBtn" onclick="toggleLive()">‚ñ∂ LIVE</button>
    <button class="btn" onclick="resetChart()">‚Ü∫ Reset</button>
  </div>
  <div class="ctrl-group" style="margin-left:auto">
    <span class="ctrl-label">Clusters:</span>
    <span class="ctrl-value" id="clusterCount" style="color:var(--text-strong)">0</span>
    <span style="font-size:9px;color:var(--text-dim);margin-left:4px" id="sourceLabel">--</span>
  </div>
</div>

<!-- ENGINE PANEL -->
<div class="engine-panel" id="enginePanel">
  <div class="engine-panel-header">
    <span>üî• Engine Analysis ‚Äî Real-time</span>
    <span style="font-size:9px;color:var(--text-dim)">Fonte: MT5 Exness | <span id="engineSourceLabel">--</span></span>
  </div>
  <div class="engine-grid">
    <div class="engine-card">
      <div class="engine-card-title">‚ö° Tick Velocity</div>
      <div class="engine-card-value">
        <span id="eng_velocity">-- t/s</span>
        <span class="dim">base: <span id="eng_velocity_base">--</span></span>
        <span class="burst" id="eng_burst" style="display:none">üî• BURST</span>
      </div>
    </div>
    <div class="engine-card">
      <div class="engine-card-title">üß© Micro Absor√ß√£o</div>
      <div class="engine-card-value">
        <span id="eng_absorption">Sem absor√ß√£o</span>
        <span class="dim">Total: <span id="eng_abs_total">0</span></span>
      </div>
    </div>
    <div class="engine-card">
      <div class="engine-card-title">üìä ATR (5s Candles)</div>
      <div class="engine-card-value">
        <span id="eng_atr">--</span>
        <span id="eng_atr_regime" class="dim">warmup</span>
      </div>
    </div>
    <div class="engine-card">
      <div class="engine-card-title">üî• Imbalance Stacking</div>
      <div class="engine-card-value">
        <span class="bull" id="eng_stack_buy">Buy: S0</span>
        <span class="bear" id="eng_stack_sell">Sell: S0</span>
        <span id="eng_dominant" style="font-weight:700"></span>
      </div>
    </div>
    <div class="engine-card">
      <div class="engine-card-title">üìâ Volatilidade</div>
      <div class="engine-card-value">
        <span id="eng_vol">-- bps</span>
        <span id="eng_vol_regime" class="dim">--</span>
      </div>
    </div>
    <div class="engine-card">
      <div class="engine-card-title">üì° Sinal Composto</div>
      <div class="engine-card-value">
        <span id="eng_signal" style="font-size:14px;font-weight:700">0%</span>
        <span class="dim" id="eng_signal_label">neutro</span>
      </div>
    </div>
  </div>
</div>

<!-- CALIBRATION PANEL -->
<div class="engine-panel" id="calibPanel" style="border-color:#9c27b044">
  <div class="engine-panel-header">
    <span style="color:#ce93d8">‚öôÔ∏è Calibragem dos Engines</span>
    <span style="font-size:9px;color:var(--text-dim)">Ajuste e estude cada motor em tempo real</span>
  </div>
  <div class="engine-grid" style="grid-template-columns:repeat(auto-fit, minmax(220px, 1fr))">
    <div class="engine-card" style="border-color:#ce93d844">
      <div class="engine-card-title" style="color:#ce93d8">üß© Micro Absor√ß√£o</div>
      <div style="font-size:8px;color:var(--text-dim);margin-bottom:4px">‚Üë Janela = absor√ß√µes maiores (institucional)</div>
      <div style="display:flex;flex-direction:column;gap:4px">
        <div class="ctrl-group" style="gap:4px"><span class="ctrl-label" style="min-width:55px">Janela</span>
          <input type="range" id="calib_mc_window" min="50" max="5000" value="100" step="50" oninput="calibEngine('micro_cluster','window_ms',this.value)" style="width:100px">
          <span class="ctrl-value" id="calib_mc_window_val">100ms</span></div>
        <div class="ctrl-group" style="gap:4px"><span class="ctrl-label" style="min-width:55px">Min Trd</span>
          <input type="range" id="calib_mc_trades" min="1" max="20" value="3" step="1" oninput="calibEngine('micro_cluster','min_trades',this.value)">
          <span class="ctrl-value" id="calib_mc_trades_val">3</span></div>
        <div class="ctrl-group" style="gap:4px"><span class="ctrl-label" style="min-width:55px">Domin.</span>
          <input type="range" id="calib_mc_dom" min="1.0" max="5.0" value="1.5" step="0.1" oninput="calibEngine('micro_cluster','dominance_ratio',this.value)">
          <span class="ctrl-value" id="calib_mc_dom_val">1.5x</span></div>
      </div>
    </div>
    <div class="engine-card" style="border-color:#ce93d844">
      <div class="engine-card-title" style="color:#ce93d8">üî• Imbalance Stacking</div>
      <div style="font-size:8px;color:var(--text-dim);margin-bottom:4px">Diagonal imbalance estilo YuCluster</div>
      <div style="display:flex;flex-direction:column;gap:4px">
        <div class="ctrl-group" style="gap:4px"><span class="ctrl-label" style="min-width:55px">Ratio</span>
          <input type="range" id="calib_id_ratio" min="1.5" max="10.0" value="3.0" step="0.5" oninput="calibEngine('imbalance_detector','imbalance_ratio',this.value)">
          <span class="ctrl-value" id="calib_id_ratio_val">3.0x</span></div>
        <div class="ctrl-group" style="gap:4px"><span class="ctrl-label" style="min-width:55px">Janela</span>
          <input type="range" id="calib_id_window" min="10" max="200" value="50" step="10" oninput="calibEngine('imbalance_detector','window_trades',this.value)">
          <span class="ctrl-value" id="calib_id_window_val">50 trd</span></div>
        <div class="ctrl-group" style="gap:4px"><span class="ctrl-label" style="min-width:55px">Stack</span>
          <input type="range" id="calib_id_stack" min="1" max="8" value="2" step="1" oninput="calibEngine('imbalance_detector','min_stacking',this.value)">
          <span class="ctrl-value" id="calib_id_stack_val">2</span></div>
      </div>
    </div>
    <div class="engine-card" style="border-color:#ce93d844">
      <div class="engine-card-title" style="color:#ce93d8">‚ö° Tick Velocity</div>
      <div class="ctrl-group" style="gap:4px"><span class="ctrl-label" style="min-width:55px">Burst X</span>
        <input type="range" id="calib_tv_burst" min="1.2" max="5.0" value="2.0" step="0.1" oninput="calibEngine('tick_velocity','burst_multiplier',this.value)">
        <span class="ctrl-value" id="calib_tv_burst_val">2.0x</span></div>
    </div>
    <div class="engine-card" style="border-color:#ce93d844">
      <div class="engine-card-title" style="color:#ce93d8">üìä ATR Normalize</div>
      <div style="display:flex;flex-direction:column;gap:4px">
        <div class="ctrl-group" style="gap:4px"><span class="ctrl-label" style="min-width:55px">Candle</span>
          <input type="range" id="calib_atr_candle" min="1" max="30" value="5" step="1" oninput="calibEngine('atr_normalize','candle_seconds',this.value)">
          <span class="ctrl-value" id="calib_atr_candle_val">5s</span></div>
        <div class="ctrl-group" style="gap:4px"><span class="ctrl-label" style="min-width:55px">Per√≠odo</span>
          <input type="range" id="calib_atr_period" min="5" max="50" value="14" step="1" oninput="calibEngine('atr_normalize','atr_period',this.value)">
          <span class="ctrl-value" id="calib_atr_period_val">14</span></div>
      </div>
    </div>
  </div>
</div>

<!-- FORMING CLUSTER STATUS -->
<div class="forming-bar" id="formingBar">
  <span style="color:var(--highlight)">üîÑ Formando</span>
  <span>Œî: <strong id="formingDelta" style="font-variant-numeric:tabular-nums">0</strong></span>
  <span style="color:var(--text-dim)">Body: <span id="formingBody">0%</span> | Wick: <span id="formingWick">0%</span></span>
  <span id="formingAbsorptions" style="color:var(--accent);display:none"></span>
  <span id="formingStacking" style="display:none"></span>
  <div class="delta-bar-bg">
    <div class="delta-bar-fill" id="deltaBarFill"></div>
  </div>
</div>

<!-- CHART -->
<div class="chart-container" id="chartContainer">
  <canvas id="chart"></canvas>
  <div class="legend">
    <div class="legend-item"><div class="legend-dot" style="background:var(--absorption-buy)"></div> Buy Absor√ß√£o</div>
    <div class="legend-item"><div class="legend-dot" style="background:var(--absorption-sell)"></div> Sell Absor√ß√£o</div>
    <div class="legend-item"><div class="legend-dot" style="background:var(--highlight)"></div> Wick &gt;50%</div>
  </div>
</div>

<script>
// ====================================================================
// IMBALANCECHART v5 ‚Äî ENGINE EDITION (Standalone Frontend)
// ====================================================================

// ---------- CONFIG ----------
const CONFIG = {
  bg: '#0a0e17',
  bgPanel: '#111827',
  bull: '#00e676',
  bear: '#ff1744',
  bullDark: '#004d40',
  bearDark: '#4a0000',
  bullBody: '#00c853',
  bearBody: '#d50000',
  highlight: '#ffd740',
  accent: '#ff6b35',
  grid: '#1a2332',
  gridStrong: '#2a3a4d',
  text: '#8899aa',
  textStrong: '#e2e8f0',
  crosshair: '#546e7a',
  absorptionBuy: '#00e676',
  absorptionSell: '#ff5252',
  clusterGap: 4,
  histogramBullColor: '#00e676',
  histogramBearColor: '#ff1744',
  histogramOpacity: 85,
  wickWarningThreshold: 50,
  pocColor: '#ffd740',
  currentPriceColor: '#00bcd4',
};

const WS_URL = 'ws://localhost:8765';
const PRICE_WIDTH = 80;
const HISTOGRAM_RATIO = 0.25; // 25% da altura para histograma (bem evidente)

// ---------- STATE ----------
let ws = null;
let isLive = false;
let allTicks = [];
let clusters = [];
let threshold = 5000;
let priceStep = 0.50; // $0.50 para XAUUSD
let viewMode = 'hybrid'; // clean | hybrid | raw
let showEnginePanel = true;
let showCalibration = false;
let lastPrice = 0;
let lastSide = 'buy';
let totalTicks = 0;
let engineState = {};
let dataSource = 'searching';
let currentSymbol = 'XAUUSD';
let weightMode = 'price_weighted';

// Symbol configurations (matching server SYM_CFG)
const SYMBOLS = {
  'BTCUSD':  { label: 'BTC/USD',  dig: 2, delta_th: 50000, step: 10.0 },
  'XAUUSD':  { label: 'XAU/USD',  dig: 2, delta_th: 5000,  step: 0.50 },
  'EURUSD':  { label: 'EUR/USD',  dig: 5, delta_th: 500,   step: 0.0001 },
  'GBPUSD':  { label: 'GBP/USD',  dig: 5, delta_th: 600,   step: 0.0001 },
  'USTEC':   { label: 'USTEC',    dig: 2, delta_th: 8000,  step: 1.0 },
};

// MEMORY FIX: Closed clusters are preserved, never recalculated
let closedClusters = [];    // Clusters j√° fechados (PERMANENTES)
let formingCluster = null;  // Cluster em forma√ß√£o (recebe novos ticks)
let formingTicks = [];      // Ticks do cluster em forma√ß√£o apenas

// View state
let viewState = {
  offsetX: 0,
  offsetY: 0,
  scaleX: 1,
  scaleY: 1,
  isDragging: false,
  lastX: 0,
  lastY: 0,
};

// Crosshair
let crosshair = { x: 0, y: 0, visible: false };

// Drawing tools
let drawTool = 'none'; // none | hline | vline | rect | trend
let drawings = [];
let currentDrawing = null;
let selectedDrawing = null;
let nextDrawId = 1;
const drawColor = '#ffd740';

// Canvas
let canvas, ctx;
let chartW, chartH, histH, totalH;

// ---------- INITIALIZATION ----------
function init() {
  canvas = document.getElementById('chart');
  ctx = canvas.getContext('2d');
  resize();
  window.addEventListener('resize', resize);
  setupCanvasEvents();
  setupControls();
  render();
  // Auto-connect
  toggleLive();
}

function resize() {
  const container = document.getElementById('chartContainer');
  const w = container.clientWidth;
  const h = container.clientHeight;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  totalH = h;
  histH = Math.floor(h * HISTOGRAM_RATIO);
  chartH = h - histH;
  chartW = w - PRICE_WIDTH;
  render();
}

// ---------- WEBSOCKET ----------
function connectWS() {
  if (ws && ws.readyState <= 1) return;
  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    document.getElementById('wsStatus').className = 'status-badge connected';
    document.getElementById('wsStatus').textContent = '‚¨§ WS CONECTADO';
    ws.send(JSON.stringify({ type: 'switch_symbol', symbol: currentSymbol }));
    // Request 24h history on connect
    ws.send(JSON.stringify({ action: 'get_history', symbol: currentSymbol, hours: 24 }));
  };

  ws.onmessage = (e) => {
    try {
      const msg = JSON.parse(e.data);
      if (msg.type === 'tick') {
        processTick(msg.data);
      } else if (msg.type === 'connected') {
        const src = msg.data?.source || 'unknown';
        dataSource = src;
        const badge = document.getElementById('binanceStatus');
        if (src === 'mt5') {
          badge.style.display = 'inline-flex';
          badge.textContent = '‚¨§ MT5 EXNESS';
          badge.className = 'status-badge connected';
        } else if (src === 'binance') {
          badge.style.display = 'inline-flex';
          badge.textContent = '‚¨§ BINANCE';
          badge.className = 'status-badge binance';
        } else {
          badge.style.display = 'inline-flex';
          badge.textContent = '‚¨§ SIMULA√á√ÉO';
          badge.className = 'status-badge disconnected';
        }
        document.getElementById('sourceLabel').textContent = src.toUpperCase();
      } else if (msg.type === 'history') {
        if (msg.ticks && msg.ticks.length > 0) {
          // Load history into clusters
          const histTicks = msg.ticks.map(t => ({
            price: t.price, volume: Math.round(t.volume_synthetic || 1),
            side: t.side || 'buy', timestamp: t.timestamp || Date.now(),
            is_absorption: false, absorption_type: null, absorption_strength: 0,
            composite_signal: 0, stacking_buy: 0, stacking_sell: 0,
          }));
          fullReprocess(histTicks);
          totalTicks = histTicks.length;
          document.getElementById('sourceLabel').textContent = `${msg.count} ticks (${msg.hours}h)`;
          render();
        } else {
          document.getElementById('sourceLabel').textContent = msg.error || 'Sem hist√≥rico';
        }
      } else if (msg.type === 'symbol_changed') {
        // Server confirmed symbol change
        if (msg.config) {
          document.getElementById('sourceLabel').textContent = msg.symbol;
        }
      } else if (msg.type === 'engine_config') {
        // Sync calibration sliders with server config
        syncCalibration(msg.data);
      } else if (msg.type === 'engine_config_updated') {
        console.log('‚öôÔ∏è Engine updated:', msg.engine, msg.params);
      }
    } catch(err) {}
  };

  ws.onclose = () => {
    document.getElementById('wsStatus').className = 'status-badge disconnected';
    document.getElementById('wsStatus').textContent = '‚¨§ DESCONECTADO';
    document.getElementById('binanceStatus').style.display = 'none';
    if (isLive) setTimeout(connectWS, 3000);
  };

  ws.onerror = () => ws.close();
}

function disconnectWS() {
  if (ws) { ws.close(); ws = null; }
  document.getElementById('wsStatus').className = 'status-badge disconnected';
  document.getElementById('wsStatus').textContent = '‚¨§ DESCONECTADO';
  document.getElementById('binanceStatus').style.display = 'none';
}

// ---------- TICK PROCESSING ----------
function processTick(data) {
  const tick = {
    price: data.price,
    volume: Math.round(data.volume_synthetic || 1),
    side: data.side || 'buy',
    timestamp: data.timestamp || Date.now(),
    is_absorption: data.is_absorption || false,
    absorption_type: data.absorption_type || null,
    absorption_strength: data.absorption_strength || 0,
    composite_signal: data.composite_signal || 0,
    stacking_buy: data.stacking_buy || 0,
    stacking_sell: data.stacking_sell || 0,
  };

  lastPrice = tick.price;
  lastSide = tick.side;
  totalTicks++;

  if (data.engines) {
    engineState = data.engines;
    updateEnginePanel();
  }

  // INCREMENTAL: s√≥ processa o tick no cluster em forma√ß√£o
  masterTicks.push(tick);
  addTickToForming(tick);

  // Merge para render
  clusters = [...closedClusters];
  if (formingCluster) clusters.push(formingCluster);

  updateUI();
  render();
}

function addTickToForming(tick) {
  const vol = tick.volume;
  const dp = priceStep > 0 ? Math.round(tick.price / priceStep) * priceStep : tick.price;

  // Se cluster atual estourou threshold ‚Üí fechar e RECALCULAR body/wick
  if (formingCluster && Math.abs(formingCluster.delta) >= threshold) {
    formingCluster.isClosed = true;
    formingCluster.endTime = tick.timestamp;
    // RECALCULAR body/wick com open/close FINAIS
    recalcBodyWick(formingCluster);
    closedClusters.push(formingCluster);
    formingCluster = null;
    formingTicks = [];
  }

  if (!formingCluster) {
    const pl = priceStep > 0 ? [{price:dp, volumeBuy:tick.side==='buy'?vol:0, volumeSell:tick.side==='sell'?vol:0, volumeTotal:vol}] : [];
    formingCluster = {
      id: closedClusters.length,
      open:dp, high:dp, low:dp, close:dp,
      volumeBuy:tick.side==='buy'?vol:0, volumeSell:tick.side==='sell'?vol:0,
      volumeTotal:vol, volumeBody:vol, volumeWick:0, wickPercent:0,
      delta:tick.side==='buy'?vol:-vol, tickCount:1, startTime:tick.timestamp,
      isClosed:false, poc:dp, priceLevels:pl,
      absorptionCount:tick.is_absorption?1:0, absorptionBuyCount:tick.absorption_type==='buy_absorption'?1:0,
      absorptionSellCount:tick.absorption_type==='sell_absorption'?1:0,
      maxAbsorptionStrength:tick.absorption_strength||0,
      maxStackingBuy:tick.stacking_buy||0, maxStackingSell:tick.stacking_sell||0,
      compositeSignalAvg:tick.composite_signal||0,
    };
    formingTicks = [tick];
    return;
  }

  // Update forming cluster (body/wick NOT calculated here ‚Äî only on close)
  const c = formingCluster;
  c.close = dp;
  c.high = Math.max(c.high, dp);
  c.low = Math.min(c.low, dp);
  c.volumeTotal += vol;
  c.tickCount++;
  formingTicks.push(tick);

  if (tick.side === 'buy') { c.volumeBuy += vol; c.delta += vol; }
  else { c.volumeSell += vol; c.delta -= vol; }

  if (priceStep > 0) {
    const ex = c.priceLevels.find(l => l.price === dp);
    if (ex) {
      if (tick.side === 'buy') ex.volumeBuy += vol; else ex.volumeSell += vol;
      ex.volumeTotal += vol;
    } else {
      c.priceLevels.push({price:dp, volumeBuy:tick.side==='buy'?vol:0, volumeSell:tick.side==='sell'?vol:0, volumeTotal:vol});
    }
    let maxV=0; for (const l of c.priceLevels) { if (l.volumeTotal>maxV) { maxV=l.volumeTotal; c.poc=l.price; } }
  }

  if (tick.is_absorption) {
    c.absorptionCount++;
    if (tick.absorption_type==='buy_absorption') c.absorptionBuyCount++;
    if (tick.absorption_type==='sell_absorption') c.absorptionSellCount++;
    c.maxAbsorptionStrength = Math.max(c.maxAbsorptionStrength, tick.absorption_strength||0);
  }
  c.maxStackingBuy = Math.max(c.maxStackingBuy, tick.stacking_buy||0);
  c.maxStackingSell = Math.max(c.maxStackingSell, tick.stacking_sell||0);
  const n = c.tickCount;
  c.compositeSignalAvg = (c.compositeSignalAvg*(n-1) + (tick.composite_signal||0)) / n;
}

// Recalculate body/wick volume ONLY when cluster closes (using final open/close)
function recalcBodyWick(cluster) {
  const bodyHigh = Math.max(cluster.open, cluster.close);
  const bodyLow = Math.min(cluster.open, cluster.close);
  let bodyVol = 0;
  let wickVol = 0;
  
  for (const level of cluster.priceLevels) {
    if (level.price >= bodyLow && level.price <= bodyHigh) {
      bodyVol += level.volumeTotal;
    } else {
      wickVol += level.volumeTotal;
    }
  }
  
  cluster.volumeBody = bodyVol;
  cluster.volumeWick = wickVol;
  cluster.wickPercent = cluster.volumeTotal > 0 ? (wickVol / cluster.volumeTotal) * 100 : 0;
}

// Full reprocess (used only when threshold/priceStep changes or history loads)
function fullReprocess(tickArray) {
  closedClusters = [];
  formingCluster = null;
  formingTicks = [];
  masterTicks = [...tickArray]; // Save for future reprocessing
  for (const tick of tickArray) addTickToForming(tick);
  clusters = [...closedClusters];
  if (formingCluster) clusters.push(formingCluster);
}

// Get all ticks (for reprocessing when params change)
// We keep a master tick list for this purpose
let masterTicks = [];

function getAllTicks() {
  return masterTicks;
}

// ---------- RENDERING ----------
function render() {
  if (!ctx) return;
  const w = canvas.width / (window.devicePixelRatio || 1);
  const h = canvas.height / (window.devicePixelRatio || 1);

  ctx.fillStyle = CONFIG.bg;
  ctx.fillRect(0, 0, w, h);

  if (clusters.length === 0) {
    ctx.fillStyle = CONFIG.text;
    ctx.font = '14px JetBrains Mono';
    ctx.textAlign = 'center';
    ctx.fillText('Aguardando ticks do MT5...', w / 2, h / 2 - 10);
    ctx.font = '11px JetBrains Mono';
    ctx.fillStyle = CONFIG.crosshair;
    ctx.fillText('Clique ‚ñ∂ LIVE para conectar ao MT5 Exness', w / 2, h / 2 + 12);
    return;
  }

  const clusterWidth = Math.max(8, 40 * viewState.scaleX);

  // Price range
  let priceHigh = -Infinity, priceLow = Infinity;
  for (const c of clusters) {
    priceHigh = Math.max(priceHigh, c.high);
    priceLow = Math.min(priceLow, c.low);
  }
  const range = (priceHigh - priceLow) * viewState.scaleY;
  const center = (priceHigh + priceLow) / 2;
  const pad = range * 0.15;
  const viewHigh = center + range / 2 + pad;
  const viewLow = center - range / 2 - pad;

  // Price conversions
  const priceToY = (p) => {
    const range = viewHigh - viewLow;
    if (range === 0 || !isFinite(range)) return chartH / 2;
    const y = ((viewHigh - p) / range) * chartH;
    return isFinite(y) ? y : chartH / 2;
  };
  const yToPrice = (y) => viewHigh - (y / chartH) * (viewHigh - viewLow);
  const clusterToX = (i) => viewState.offsetX + i * (clusterWidth + CONFIG.clusterGap) + clusterWidth / 2;

  // Max volume
  let maxVolume = 1;
  for (const c of clusters) maxVolume = Math.max(maxVolume, c.volumeTotal);

  // ========== GRID ==========
  ctx.lineWidth = 0.5;
  const gridLines = 10;
  const gridStep = (viewHigh - viewLow) / gridLines;
  for (let i = 0; i <= gridLines; i++) {
    const y = (chartH / gridLines) * i;
    const price = viewHigh - gridStep * i;

    // Alternate stronger lines
    ctx.strokeStyle = i % 2 === 0 ? CONFIG.gridStrong + '66' : CONFIG.grid + '44';
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(chartW, y);
    ctx.stroke();

    // Price label
    ctx.fillStyle = CONFIG.text;
    ctx.font = '9px JetBrains Mono';
    ctx.textAlign = 'left';
    ctx.fillText(price.toFixed(2), chartW + 5, y + 3);
  }

  // Price scale separator
  ctx.strokeStyle = CONFIG.gridStrong;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(chartW, 0);
  ctx.lineTo(chartW, totalH);
  ctx.stroke();

  // ========== CURRENT PRICE LINE ==========
  if (lastPrice > 0 && lastPrice >= viewLow && lastPrice <= viewHigh) {
    const cpY = priceToY(lastPrice);
    ctx.strokeStyle = CONFIG.currentPriceColor;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([8, 4]);
    ctx.beginPath();
    ctx.moveTo(0, cpY);
    ctx.lineTo(chartW, cpY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Price label box on right
    ctx.fillStyle = CONFIG.currentPriceColor;
    ctx.fillRect(chartW + 1, cpY - 10, PRICE_WIDTH - 6, 20);
    ctx.fillStyle = '#000';
    ctx.font = 'bold 10px JetBrains Mono';
    ctx.textAlign = 'left';
    ctx.fillText('$' + lastPrice.toFixed(2), chartW + 4, cpY + 4);

    // Small arrow
    ctx.fillStyle = CONFIG.currentPriceColor;
    ctx.beginPath();
    ctx.moveTo(chartW, cpY);
    ctx.lineTo(chartW - 6, cpY - 5);
    ctx.lineTo(chartW - 6, cpY + 5);
    ctx.closePath();
    ctx.fill();
  }

  // ========== CLUSTERS ==========
  for (let idx = 0; idx < clusters.length; idx++) {
    const cluster = clusters[idx];
    const centerX = clusterToX(idx);
    const x = centerX - clusterWidth / 2;
    const cw = clusterWidth;

    if (centerX < -cw || centerX > chartW + cw) continue;

    const isBull = cluster.close >= cluster.open;
    const deltaIntensity = Math.min(1, Math.abs(cluster.delta) / (threshold * 0.8));

    // ===== WICK LINE =====
    const highY = priceToY(cluster.high);
    const lowY = priceToY(cluster.low);
    ctx.strokeStyle = isBull ? CONFIG.bull + 'aa' : CONFIG.bear + 'aa';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(centerX, highY);
    ctx.lineTo(centerX, lowY);
    ctx.stroke();

    // ===== BODY =====
    let bodyTop = priceToY(Math.max(cluster.open, cluster.close));
    let bodyBottom = priceToY(Math.min(cluster.open, cluster.close));
    // Guard: if priceToY returns NaN/Infinity (happens when viewHigh===viewLow or no range)
    if (!isFinite(bodyTop)) bodyTop = chartH / 2 - 5;
    if (!isFinite(bodyBottom)) bodyBottom = chartH / 2 + 5;
    const bodyH = Math.max(3, bodyBottom - bodyTop);

    // Body fill with gradient based on delta intensity
    const alphaHex = Math.round(40 + deltaIntensity * 180).toString(16).padStart(2, '0');
    const borderAlpha = Math.round(120 + deltaIntensity * 135).toString(16).padStart(2, '0');

    if (viewMode === 'clean') {
      // Solid fill with intensity
      ctx.fillStyle = isBull ? CONFIG.bullBody + alphaHex : CONFIG.bearBody + alphaHex;
      ctx.fillRect(x, bodyTop, cw, bodyH);
    } else {
      // Gradient fill
      const grad = ctx.createLinearGradient(x, bodyTop, x, bodyTop + bodyH);
      if (isBull) {
        grad.addColorStop(0, CONFIG.bull + alphaHex);
        grad.addColorStop(0.5, CONFIG.bullBody + Math.round(60 + deltaIntensity * 160).toString(16).padStart(2, '0'));
        grad.addColorStop(1, CONFIG.bullDark + alphaHex);
      } else {
        grad.addColorStop(0, CONFIG.bearDark + alphaHex);
        grad.addColorStop(0.5, CONFIG.bearBody + Math.round(60 + deltaIntensity * 160).toString(16).padStart(2, '0'));
        grad.addColorStop(1, CONFIG.bear + alphaHex);
      }
      ctx.fillStyle = grad;
      ctx.fillRect(x, bodyTop, cw, bodyH);
    }

    // Body border
    ctx.strokeStyle = isBull ? CONFIG.bull + borderAlpha : CONFIG.bear + borderAlpha;
    ctx.lineWidth = 1.5;
    ctx.strokeRect(x, bodyTop, cw, bodyH);

    // Delta label inside body (when zoomed enough)
    if (viewState.scaleX >= 0.9 && bodyH > 14) {
      ctx.fillStyle = isBull ? '#ffffff' + borderAlpha : '#ffffff' + borderAlpha;
      ctx.font = 'bold 8px JetBrains Mono';
      ctx.textAlign = 'center';
      const deltaText = (cluster.delta >= 0 ? '+' : '') + (Math.abs(cluster.delta) >= 1000 ? (cluster.delta / 1000).toFixed(1) + 'k' : cluster.delta);
      ctx.fillText(deltaText, centerX, bodyTop + bodyH / 2 + 3);
    }

    // ===== POC LINE (VERY EVIDENT) =====
    if (cluster.priceLevels.length > 0) {
      const pocY = priceToY(cluster.poc);

      // Glow effect (3 layers)
      ctx.strokeStyle = CONFIG.pocColor + '22';
      ctx.lineWidth = 7;
      ctx.beginPath();
      ctx.moveTo(x - 6, pocY);
      ctx.lineTo(x + cw + 6, pocY);
      ctx.stroke();

      ctx.strokeStyle = CONFIG.pocColor + '55';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x - 5, pocY);
      ctx.lineTo(x + cw + 5, pocY);
      ctx.stroke();

      ctx.strokeStyle = CONFIG.pocColor;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x - 4, pocY);
      ctx.lineTo(x + cw + 4, pocY);
      ctx.stroke();

      // POC diamond marker
      ctx.fillStyle = CONFIG.pocColor;
      ctx.beginPath();
      ctx.moveTo(x - 6, pocY);
      ctx.lineTo(x - 3, pocY - 3);
      ctx.lineTo(x, pocY);
      ctx.lineTo(x - 3, pocY + 3);
      ctx.closePath();
      ctx.fill();

      // POC price label (when zoomed)
      if (viewState.scaleX >= 1.2) {
        ctx.fillStyle = CONFIG.pocColor;
        ctx.font = 'bold 7px JetBrains Mono';
        ctx.textAlign = 'center';
        ctx.fillText('POC', centerX, pocY - 5);
      }
    }

    // ========== FOOTPRINT (Hybrid / Raw) ==========
    if (viewMode !== 'clean' && cluster.priceLevels.length > 0) {
      const maxLevelVol = Math.max(...cluster.priceLevels.map(l => l.volumeTotal));
      const barRatio = viewMode === 'raw' ? 0.9 : 0.65;

      for (const level of cluster.priceLevels) {
        const ly = priceToY(level.price);
        const volRatio = level.volumeTotal / maxLevelVol;
        const barW = volRatio * cw * barRatio;

        // Colored bars with higher opacity based on volume concentration
        const levelAlpha = Math.round(80 + volRatio * 175).toString(16).padStart(2, '0');
        const isBuyDom = level.volumeBuy >= level.volumeSell;
        ctx.fillStyle = (isBuyDom ? CONFIG.histogramBullColor : CONFIG.histogramBearColor) + levelAlpha;
        ctx.fillRect(centerX - barW / 2, ly - 1.5, barW, 3);

        // Bright edge for high-volume levels
        if (volRatio > 0.7) {
          ctx.fillStyle = (isBuyDom ? '#b9f6ca' : '#ffcdd2') + '66';
          ctx.fillRect(centerX - barW / 2, ly - 0.5, barW, 1);
        }

        // Volume text on raw mode
        if (viewMode === 'raw' && viewState.scaleX >= 1.5 && level.volumeTotal > 0) {
          ctx.fillStyle = isBuyDom ? CONFIG.bull + 'cc' : CONFIG.bear + 'cc';
          ctx.font = '6px JetBrains Mono';
          ctx.textAlign = 'center';
          ctx.fillText(level.volumeTotal.toString(), centerX, ly + 6);
        }
      }
    }

    // Volume labels
    if (viewState.scaleX >= 1) {
      ctx.font = '7px JetBrains Mono';
      ctx.textAlign = 'center';
      // Wick vol
      ctx.fillStyle = '#667788';
      ctx.fillText('W:' + cluster.volumeWick, centerX, lowY + 10);
      // Body vol
      ctx.fillStyle = isBull ? CONFIG.bull + 'cc' : CONFIG.bear + 'cc';
      ctx.fillText('B:' + cluster.volumeBody, centerX, highY - 4);
    }

    // Forming cluster dashed border
    if (!cluster.isClosed) {
      ctx.strokeStyle = CONFIG.highlight;
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 3]);
      ctx.strokeRect(x - 1, bodyTop - 1, cw + 2, bodyH + 2);
      ctx.setLineDash([]);

      // Pulsing glow for forming cluster
      ctx.shadowColor = CONFIG.highlight;
      ctx.shadowBlur = 6;
      ctx.strokeStyle = CONFIG.highlight + '44';
      ctx.lineWidth = 1;
      ctx.strokeRect(x - 2, bodyTop - 2, cw + 4, bodyH + 4);
      ctx.shadowBlur = 0;
    }

    // ========== WICK WARNING ==========
    if (cluster.wickPercent >= CONFIG.wickWarningThreshold) {
      const warningY = lowY + 16;

      // Glow
      ctx.shadowColor = CONFIG.highlight;
      ctx.shadowBlur = 8;
      ctx.fillStyle = CONFIG.highlight;
      ctx.beginPath();
      ctx.arc(centerX, warningY, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Inner dot
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(centerX, warningY, 2, 0, Math.PI * 2);
      ctx.fill();

      if (viewState.scaleX >= 0.8) {
        ctx.fillStyle = CONFIG.highlight;
        ctx.font = 'bold 8px JetBrains Mono';
        ctx.textAlign = 'center';
        ctx.fillText(cluster.wickPercent.toFixed(0) + '%', centerX, warningY + 13);
      }
    }

    // ========== ENGINE OVERLAYS ==========

    // üß© Absorption markers
    if (cluster.absorptionCount > 0) {
      const ms = Math.min(6, Math.max(3, cw * 0.3));

      if (cluster.absorptionBuyCount > cluster.absorptionSellCount) {
        // Buy absorption: green triangle below
        ctx.fillStyle = CONFIG.absorptionBuy;
        ctx.beginPath();
        ctx.moveTo(centerX, lowY + ms * 3);
        ctx.lineTo(centerX - ms, lowY + ms * 3 + ms * 1.5);
        ctx.lineTo(centerX + ms, lowY + ms * 3 + ms * 1.5);
        ctx.closePath();
        ctx.fill();
        if (cluster.absorptionBuyCount > 1 && viewState.scaleX >= 0.8) {
          ctx.fillStyle = CONFIG.absorptionBuy;
          ctx.font = 'bold 7px JetBrains Mono';
          ctx.textAlign = 'center';
          ctx.fillText('' + cluster.absorptionBuyCount, centerX, lowY + ms * 3 + ms * 1.5 + 10);
        }
      } else if (cluster.absorptionSellCount > 0) {
        // Sell absorption: red triangle above
        ctx.fillStyle = CONFIG.absorptionSell;
        ctx.beginPath();
        ctx.moveTo(centerX, highY - ms * 3);
        ctx.lineTo(centerX - ms, highY - ms * 3 - ms * 1.5);
        ctx.lineTo(centerX + ms, highY - ms * 3 - ms * 1.5);
        ctx.closePath();
        ctx.fill();
        if (cluster.absorptionSellCount > 1 && viewState.scaleX >= 0.8) {
          ctx.fillStyle = CONFIG.absorptionSell;
          ctx.font = 'bold 7px JetBrains Mono';
          ctx.textAlign = 'center';
          ctx.fillText('' + cluster.absorptionSellCount, centerX, highY - ms * 3 - ms * 1.5 - 4);
        }
      }
    }

    // üî• Stacking bars
    if (cluster.maxStackingBuy >= 2 || cluster.maxStackingSell >= 2) {
      const barW2 = Math.max(2, cw * 0.12);
      const bTop = bodyTop;
      const bH = Math.max(4, bodyH);

      if (cluster.maxStackingBuy >= 2) {
        const intensity = Math.min(cluster.maxStackingBuy / 5, 1);
        const alpha = Math.round(intensity * 200 + 55).toString(16).padStart(2, '0');
        ctx.fillStyle = CONFIG.absorptionBuy + alpha;
        ctx.fillRect(x - barW2 - 1, bTop, barW2, bH);
        if (viewState.scaleX >= 0.8) {
          ctx.fillStyle = CONFIG.absorptionBuy;
          ctx.font = 'bold 7px JetBrains Mono';
          ctx.textAlign = 'right';
          ctx.fillText('S' + cluster.maxStackingBuy, x - barW2 - 2, bTop + bH / 2 + 3);
        }
      }
      if (cluster.maxStackingSell >= 2) {
        const intensity = Math.min(cluster.maxStackingSell / 5, 1);
        const alpha = Math.round(intensity * 200 + 55).toString(16).padStart(2, '0');
        ctx.fillStyle = CONFIG.absorptionSell + alpha;
        ctx.fillRect(x + cw + 1, bTop, barW2, bH);
        if (viewState.scaleX >= 0.8) {
          ctx.fillStyle = CONFIG.absorptionSell;
          ctx.font = 'bold 7px JetBrains Mono';
          ctx.textAlign = 'left';
          ctx.fillText('S' + cluster.maxStackingSell, x + cw + barW2 + 2, bTop + bH / 2 + 3);
        }
      }
    }

    // üìä Composite signal dot
    if (Math.abs(cluster.compositeSignalAvg) > 0.2 && viewState.scaleX >= 0.7) {
      const dotX = x + cw - 3;
      const dotY = highY - 2;
      const dotSize = Math.min(4, 2 + Math.abs(cluster.compositeSignalAvg) * 3);
      ctx.fillStyle = cluster.compositeSignalAvg > 0 ? CONFIG.absorptionBuy + '88' : CONFIG.absorptionSell + '88';
      ctx.beginPath();
      ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // ========== VOLUME HISTOGRAM (DUAL BAR ‚Äî VERY EVIDENT) ==========
  if (histH > 0) {
    const histY = chartH;
    const labelH = 14;
    const gap = 4;
    const availH = histH - labelH - gap;
    const bar1H = availH * 0.55; // Volume total (bigger)
    const bar2H = availH * 0.45; // Body/Wick split

    // Background with subtle gradient
    const histGrad = ctx.createLinearGradient(0, histY, 0, histY + histH);
    histGrad.addColorStop(0, '#0f1923');
    histGrad.addColorStop(1, '#0a0e17');
    ctx.fillStyle = histGrad;
    ctx.fillRect(0, histY, chartW + PRICE_WIDTH, histH);

    // Separator line (bright)
    ctx.strokeStyle = '#334455';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, histY);
    ctx.lineTo(chartW + PRICE_WIDTH, histY);
    ctx.stroke();

    // Middle separator (between bar1 and bar2)
    const midY = histY + labelH + bar1H + gap / 2;
    ctx.strokeStyle = '#1e2d3d';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(0, midY);
    ctx.lineTo(chartW, midY);
    ctx.stroke();

    // Labels
    ctx.font = 'bold 8px JetBrains Mono';
    ctx.textAlign = 'left';
    ctx.fillStyle = CONFIG.highlight;
    ctx.fillText('VOL', 4, histY + 10);
    ctx.fillStyle = '#667788';
    ctx.fillText('BODY/WICK', 4, midY + 10);

    for (let idx = 0; idx < clusters.length; idx++) {
      const cluster = clusters[idx];
      const centerX = clusterToX(idx);
      const x = centerX - clusterWidth / 2;
      if (centerX < -clusterWidth || centerX > chartW + clusterWidth) continue;

      const isBull = cluster.close >= cluster.open;
      const volRatio = cluster.volumeTotal / maxVolume;

      // ===== BAR 1: VOLUME TOTAL (top) =====
      const v1H = volRatio * (bar1H - 4);
      const v1Y = histY + labelH + bar1H - v1H;

      // Gradient bar
      const vGrad = ctx.createLinearGradient(x, v1Y, x, v1Y + v1H);
      if (isBull) {
        vGrad.addColorStop(0, CONFIG.bull);
        vGrad.addColorStop(1, CONFIG.bullDark + 'cc');
      } else {
        vGrad.addColorStop(0, CONFIG.bear);
        vGrad.addColorStop(1, CONFIG.bearDark + 'cc');
      }
      ctx.fillStyle = vGrad;
      ctx.fillRect(x + 0.5, v1Y, clusterWidth - 1, v1H);

      // Bright top edge
      ctx.fillStyle = isBull ? '#b9f6ca55' : '#ffcdd255';
      ctx.fillRect(x + 0.5, v1Y, clusterWidth - 1, Math.min(2, v1H));

      // Volume text on big bars
      if (volRatio > 0.3 && viewState.scaleX >= 0.8 && v1H > 10) {
        ctx.fillStyle = '#ffffffbb';
        ctx.font = '7px JetBrains Mono';
        ctx.textAlign = 'center';
        const vText = cluster.volumeTotal >= 1000 ? (cluster.volumeTotal / 1000).toFixed(1) + 'k' : '' + cluster.volumeTotal;
        ctx.fillText(vText, centerX, v1Y + v1H / 2 + 3);
      }

      // ===== BAR 2: BODY / WICK SPLIT (bottom) =====
      const v2H = volRatio * (bar2H - 4);
      const v2Y = midY + gap / 2;

      if (cluster.volumeTotal > 0) {
        const bodyPct = cluster.volumeBody / cluster.volumeTotal;
        const wickPct = cluster.volumeWick / cluster.volumeTotal;
        const bodyBarH = v2H * bodyPct;
        const wickBarH = v2H * wickPct;
        const baseY2 = v2Y + bar2H - v2H;

        // Wick part (bottom of bar)
        if (wickBarH > 0) {
          const wickColor = cluster.wickPercent >= 50 ? '#ffd740' : '#455a64';
          ctx.fillStyle = wickColor + 'cc';
          ctx.fillRect(x + 0.5, baseY2, clusterWidth - 1, wickBarH);
        }
        // Body part (top of bar, stacked on wick)
        if (bodyBarH > 0) {
          ctx.fillStyle = isBull ? '#4caf50cc' : '#e53935cc';
          ctx.fillRect(x + 0.5, baseY2 + wickBarH, clusterWidth - 1, bodyBarH);
        }
      }

      // Wick warning highlight at bottom
      if (cluster.wickPercent >= CONFIG.wickWarningThreshold) {
        ctx.fillStyle = CONFIG.highlight + 'aa';
        ctx.fillRect(x, histY + histH - 3, clusterWidth, 3);
      }
    }
  }

  // ========== DRAWINGS ==========
  for (const d of drawings) {
    const isSel = d.id === selectedDrawing;
    ctx.strokeStyle = d.color;
    ctx.lineWidth = isSel ? 2.5 : 1.5;
    
    if (d.type === 'hline') {
      const y = priceToY(d.p1.y);
      ctx.setLineDash(isSel ? [] : [6, 4]);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(chartW, y);
      ctx.stroke();
      ctx.setLineDash([]);
      // Price label
      ctx.fillStyle = d.color;
      ctx.font = 'bold 9px JetBrains Mono';
      ctx.textAlign = 'left';
      const symDig = (SYMBOLS[currentSymbol] || {}).dig || 2;
      ctx.fillText(d.p1.y.toFixed(symDig), chartW + 4, y - 3);
      if (isSel) {
        ctx.beginPath();
        ctx.arc(chartW - 8, y, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    else if (d.type === 'vline') {
      const vx = clusterToX(d.p1.x);
      ctx.beginPath();
      ctx.moveTo(vx, 0);
      ctx.lineTo(vx, chartH);
      ctx.stroke();
    }
    else if (d.type === 'rect' && d.p1 && d.p2) {
      const x1 = clusterToX(d.p1.x), y1 = priceToY(d.p1.y);
      const x2 = clusterToX(d.p2.x), y2 = priceToY(d.p2.y);
      ctx.fillStyle = d.color + '18';
      ctx.fillRect(Math.min(x1,x2), Math.min(y1,y2), Math.abs(x2-x1), Math.abs(y2-y1));
      ctx.strokeRect(Math.min(x1,x2), Math.min(y1,y2), Math.abs(x2-x1), Math.abs(y2-y1));
    }
    else if (d.type === 'trend' && d.p1 && d.p2) {
      const x1 = clusterToX(d.p1.x), y1 = priceToY(d.p1.y);
      const x2 = clusterToX(d.p2.x), y2 = priceToY(d.p2.y);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      // Extend line
      const dx = x2-x1, dy = y2-y1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(x1 - dx * 5, y1 - dy * 5);
      ctx.lineTo(x2 + dx * 5, y2 + dy * 5);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  // Drawing in progress preview
  if (currentDrawing && currentDrawing.p1) {
    ctx.strokeStyle = currentDrawing.color + 'aa';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    if (currentDrawing.type === 'rect' || currentDrawing.type === 'trend') {
      const x1 = clusterToX(currentDrawing.p1.x);
      const y1 = priceToY(currentDrawing.p1.y);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(crosshair.x, crosshair.y);
      ctx.stroke();
    }
    ctx.setLineDash([]);
  }

  // ========== CROSSHAIR ==========
  if (crosshair.visible) {
    ctx.strokeStyle = CONFIG.crosshair;
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);

    ctx.beginPath();
    ctx.moveTo(crosshair.x, 0);
    ctx.lineTo(crosshair.x, totalH);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0, crosshair.y);
    ctx.lineTo(chartW, crosshair.y);
    ctx.stroke();
    ctx.setLineDash([]);

    // Price label
    if (crosshair.y < chartH) {
      const price = yToPrice(crosshair.y);
      ctx.fillStyle = CONFIG.highlight;
      ctx.fillRect(chartW + 1, crosshair.y - 10, PRICE_WIDTH - 6, 20);
      ctx.fillStyle = '#000';
      ctx.font = 'bold 10px JetBrains Mono';
      ctx.textAlign = 'left';
      ctx.fillText(price.toFixed(2), chartW + 4, crosshair.y + 4);
    }
  }

  // ========== HEADER OVERLAY ==========
  ctx.fillStyle = '#0a0e17ee';
  ctx.fillRect(0, 0, 420, 34);
  ctx.fillStyle = CONFIG.highlight;
  ctx.font = 'bold 12px JetBrains Mono';
  ctx.textAlign = 'left';
  ctx.fillText(`${(SYMBOLS[currentSymbol]||{}).label||currentSymbol} | ${viewMode.toUpperCase()} | MT5 LIVE`, 8, 13);
  ctx.fillStyle = CONFIG.text;
  ctx.font = '9px JetBrains Mono';
  const closedCount = clusters.filter(c => c.isClosed).length;
  ctx.fillText(`Clusters: ${closedCount} | Œî: ${threshold >= 1000 ? (threshold/1000)+'k' : threshold} | Step: $${priceStep.toFixed(0)} | Zoom: ${(viewState.scaleX * 100).toFixed(0)}%`, 8, 26);

  // Legend (top right)
  ctx.fillStyle = CONFIG.bgPanel + 'dd';
  ctx.fillRect(chartW - 210, 0, 210, 28);
  ctx.font = '7px JetBrains Mono';
  ctx.textAlign = 'left';
  ctx.fillStyle = CONFIG.absorptionBuy; ctx.fillText('‚ñ≤ Buy Absor√ß√£o', chartW - 205, 10);
  ctx.fillStyle = CONFIG.absorptionSell; ctx.fillText('‚ñº Sell Absor√ß√£o', chartW - 205, 20);
  ctx.fillStyle = CONFIG.absorptionBuy; ctx.fillText('‚ïë Stacking Buy', chartW - 110, 10);
  ctx.fillStyle = CONFIG.absorptionSell; ctx.fillText('‚ïë Stacking Sell', chartW - 110, 20);

  // ========== MINIMAP ==========
  if (clusters.length > 2) {
    const mmW = 100, mmH = 24;
    const mmX = chartW - mmW - 8;
    const mmY = chartH - mmH - 8;

    ctx.fillStyle = CONFIG.bgPanel;
    ctx.fillRect(mmX, mmY, mmW, mmH);
    ctx.strokeStyle = CONFIG.gridStrong;
    ctx.lineWidth = 1;
    ctx.strokeRect(mmX, mmY, mmW, mmH);

    const mmScale = mmW / clusters.length;
    for (let i = 0; i < clusters.length; i++) {
      const c = clusters[i];
      const mx = mmX + i * mmScale;
      ctx.fillStyle = (c.close >= c.open ? CONFIG.bull : CONFIG.bear) + '77';
      ctx.fillRect(mx, mmY + 2, Math.max(1, mmScale), mmH - 4);
      if (c.wickPercent >= CONFIG.wickWarningThreshold) {
        ctx.fillStyle = CONFIG.highlight + 'cc';
        ctx.fillRect(mx, mmY + mmH - 4, Math.max(1, mmScale), 3);
      }
      // Absorption marker in minimap
      if (c.absorptionCount > 0) {
        ctx.fillStyle = c.absorptionBuyCount > c.absorptionSellCount ? CONFIG.absorptionBuy + '88' : CONFIG.absorptionSell + '88';
        ctx.fillRect(mx, mmY, Math.max(1, mmScale), 3);
      }
    }

    const totalWidth = clusters.length * (clusterWidth + CONFIG.clusterGap);
    const vpW = (chartW / totalWidth) * mmW;
    const vpX = mmX + (-viewState.offsetX / totalWidth) * mmW;
    ctx.strokeStyle = CONFIG.highlight;
    ctx.lineWidth = 2;
    ctx.strokeRect(Math.max(mmX, vpX), mmY, Math.min(vpW, mmW), mmH);
  }
}

// ---------- CANVAS EVENTS ----------
function setupCanvasEvents() {
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    crosshair = { x: Math.min(x, chartW), y, visible: true };

    if (viewState.isDragging) {
      if (viewState.dragMode === 'zoom') {
        // Vertical zoom: drag up = zoom in (stretch clusters), drag down = zoom out
        const dy = e.clientY - viewState.lastY;
        const zoomFactor = 1 + dy * 0.005;
        viewState.scaleY = Math.max(0.1, Math.min(20, viewState.scaleY * zoomFactor));
        viewState.lastY = e.clientY;
      } else if (viewState.dragMode === 'moveDrawing' && selectedDrawing !== null) {
        // Move selected hline drawing
        const drawing = drawings.find(d => d.id === selectedDrawing);
        if (drawing && drawing.type === 'hline') {
          drawing.p1.y = yToPrice(y);
        }
      } else if (viewState.dragMode === 'draw') {
        // Drawing in progress (handled below)
      } else {
        // Pan
        const dx = e.clientX - viewState.lastX;
        viewState.offsetX += dx;
        viewState.lastX = e.clientX;
      }
    }
    render();
  });

  canvas.addEventListener('mouseleave', () => {
    crosshair.visible = false;
    viewState.isDragging = false;
    render();
  });

  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (x > chartW) {
      // Price scale drag ‚Üí vertical zoom
      viewState.isDragging = true;
      viewState.lastY = e.clientY;
      viewState.dragMode = 'zoom';
    } else if (drawTool !== 'none') {
      // Drawing mode
      const price = yToPrice(y);
      const clusterIdx = Math.round((x - viewState.offsetX) / (Math.max(8, 40 * viewState.scaleX) + CONFIG.clusterGap));
      
      if (!currentDrawing) {
        currentDrawing = {
          id: nextDrawId++,
          type: drawTool,
          p1: { x: clusterIdx, y: price },
          p2: null,
          color: drawColor,
        };
        // hline completes immediately
        if (drawTool === 'hline') {
          drawings.push({ ...currentDrawing });
          currentDrawing = null;
          setDrawTool('none');
        } else if (drawTool === 'vline') {
          drawings.push({ ...currentDrawing });
          currentDrawing = null;
          setDrawTool('none');
        }
      } else {
        // Second click completes rect/trend
        currentDrawing.p2 = { x: clusterIdx, y: price };
        drawings.push({ ...currentDrawing });
        currentDrawing = null;
        setDrawTool('none');
      }
      render();
    } else {
      // Check if clicking on existing drawing
      selectedDrawing = null;
      for (const d of drawings) {
        if (d.type === 'hline') {
          const dy = Math.abs(priceToY(d.p1.y) - y);
          if (dy < 6) { selectedDrawing = d.id; break; }
        }
      }
      viewState.isDragging = true;
      viewState.lastX = e.clientX;
      viewState.dragMode = selectedDrawing ? 'moveDrawing' : 'pan';
    }
  });

  canvas.addEventListener('mouseup', () => {
    viewState.isDragging = false;
  });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    if (e.ctrlKey) {
      // Horizontal zoom
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      viewState.scaleX = Math.max(0.2, Math.min(15, viewState.scaleX * delta));
    } else if (e.shiftKey) {
      // Vertical zoom
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      viewState.scaleY = Math.max(0.1, Math.min(20, viewState.scaleY * delta));
    } else {
      // Pan
      viewState.offsetX += e.deltaY > 0 ? 50 : -50;
    }
    render();
  }, { passive: false });

  // Keyboard: Delete/Backspace to remove selected drawing, Escape to cancel tool
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (selectedDrawing !== null && document.activeElement === document.body) {
        e.preventDefault();
        deleteSelectedDrawing();
      }
    }
    if (e.key === 'Escape') {
      setDrawTool('none');
      currentDrawing = null;
      selectedDrawing = null;
      render();
    }
  });
}

// Helper: convert Y pixel to price (inverse of priceToY)
function yToPrice(y) {
  if (clusters.length === 0) return 0;
  let pH = -Infinity, pL = Infinity;
  for (const c of clusters) { pH = Math.max(pH, c.high); pL = Math.min(pL, c.low); }
  const range = (pH - pL) * viewState.scaleY;
  const center = (pH + pL) / 2;
  const pad = range * 0.15;
  const vH = center + range / 2 + pad;
  const vL = center - range / 2 - pad;
  const r = vH - vL;
  return r === 0 ? center : vH - (y / chartH) * r;
}

// ---------- CONTROLS ----------
function setupControls() {
  const thSlider = document.getElementById('thresholdSlider');
  const thValue = document.getElementById('thresholdValue');
  thSlider.addEventListener('input', () => {
    threshold = Number(thSlider.value);
    thValue.textContent = threshold >= 1000 ? (threshold / 1000) + 'k' : threshold;
    const allT = getAllTicks();
    if (allT.length > 0) fullReprocess(allT);
    render();
  });

  const stSlider = document.getElementById('stepSlider');
  const stValue = document.getElementById('stepValue');
  stSlider.addEventListener('input', () => {
    const val = Number(stSlider.value);
    const sym = SYMBOLS[currentSymbol] || {};
    const baseStep = sym.step || 0.01;
    priceStep = val === 0 ? 0 : val * baseStep;
    stValue.textContent = priceStep === 0 ? 'AUTO' : (priceStep >= 1 ? '$' + priceStep.toFixed(0) : priceStep.toFixed(4));
    // Reprocess with all saved ticks
    const allT = getAllTicks();
    if (allT.length > 0) fullReprocess(allT);
    render();
  });
}

function syncCalibration(config) {
  if (!config) return;
  const sync = (id, engine, param, fmt) => {
    const el = document.getElementById(id);
    const valEl = document.getElementById(id + '_val');
    if (el && config[engine] && config[engine][param] !== undefined) {
      el.value = config[engine][param];
      if (valEl && fmt) valEl.textContent = fmt(config[engine][param]);
    }
  };
  sync('calib_mc_window', 'micro_cluster', 'window_ms', v => v + 'ms');
  sync('calib_mc_trades', 'micro_cluster', 'min_trades', v => v);
  sync('calib_mc_dom', 'micro_cluster', 'dominance_ratio', v => parseFloat(v).toFixed(1) + 'x');
  sync('calib_id_ratio', 'imbalance_detector', 'imbalance_ratio', v => parseFloat(v).toFixed(1) + 'x');
  sync('calib_id_window', 'imbalance_detector', 'window_trades', v => v + ' trd');
  sync('calib_id_stack', 'imbalance_detector', 'min_stacking', v => v);
  sync('calib_tv_burst', 'tick_velocity', 'burst_multiplier', v => parseFloat(v).toFixed(1) + 'x');
  sync('calib_atr_candle', 'atr_normalize', 'candle_seconds', v => v + 's');
  sync('calib_atr_period', 'atr_normalize', 'atr_period', v => v);
}

function setViewMode(mode) {
  viewMode = mode;
  document.querySelectorAll('[data-mode]').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.mode === mode);
  });
  render();
}

function setDrawTool(tool) {
  drawTool = tool;
  currentDrawing = null;
  document.querySelectorAll('[data-draw]').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.draw === tool);
  });
  canvas.style.cursor = tool !== 'none' ? 'crosshair' : 'crosshair';
}

function clearDrawings() {
  drawings = [];
  selectedDrawing = null;
  currentDrawing = null;
  render();
}

function deleteSelectedDrawing() {
  if (selectedDrawing !== null) {
    drawings = drawings.filter(d => d.id !== selectedDrawing);
    selectedDrawing = null;
    render();
  }
}

function toggleEnginePanel() {
  showEnginePanel = !showEnginePanel;
  document.getElementById('enginePanel').classList.toggle('visible', showEnginePanel);
  document.getElementById('engineToggle').classList.toggle('active', showEnginePanel);
  resize();
}

function toggleLive() {
  isLive = !isLive;
  const btn = document.getElementById('liveBtn');
  if (isLive) {
    btn.textContent = '‚èπ PARAR';
    btn.classList.add('stopped');
    connectWS();
  } else {
    btn.textContent = '‚ñ∂ LIVE';
    btn.classList.remove('stopped');
    disconnectWS();
  }
}

function toggleCalibration() {
  showCalibration = !showCalibration;
  document.getElementById('calibPanel').classList.toggle('visible', showCalibration);
  document.getElementById('calibToggle').classList.toggle('active', showCalibration);
  resize();
}

function calibEngine(engine, param, value) {
  // Update local display
  const fmtMap = {
    'window_ms': v => v + 'ms',
    'min_trades': v => v,
    'dominance_ratio': v => parseFloat(v).toFixed(1) + 'x',
    'imbalance_ratio': v => parseFloat(v).toFixed(1) + 'x',
    'window_trades': v => v + ' trd',
    'min_stacking': v => v,
    'burst_multiplier': v => parseFloat(v).toFixed(1) + 'x',
    'candle_seconds': v => v + 's',
    'atr_period': v => v,
  };
  const ids = {
    'micro_cluster_window_ms': 'calib_mc_window_val',
    'micro_cluster_min_trades': 'calib_mc_trades_val',
    'micro_cluster_dominance_ratio': 'calib_mc_dom_val',
    'imbalance_detector_imbalance_ratio': 'calib_id_ratio_val',
    'imbalance_detector_window_trades': 'calib_id_window_val',
    'imbalance_detector_min_stacking': 'calib_id_stack_val',
    'tick_velocity_burst_multiplier': 'calib_tv_burst_val',
    'atr_normalize_candle_seconds': 'calib_atr_candle_val',
    'atr_normalize_atr_period': 'calib_atr_period_val',
  };
  const key = engine + '_' + param;
  const el = document.getElementById(ids[key]);
  if (el && fmtMap[param]) el.textContent = fmtMap[param](value);

  // Send to backend
  if (ws && ws.readyState === 1) {
    ws.send(JSON.stringify({
      type: 'set_engine_config',
      engine: engine,
      params: { [param]: parseFloat(value) }
    }));
  }
}

function switchSymbol(sym) {
  currentSymbol = sym;
  if (ws && ws.readyState === 1) {
    ws.send(JSON.stringify({ type: 'switch_symbol', symbol: sym }));
    // Auto-load 24h history for new symbol
    setTimeout(() => loadHistory(24), 500);
  }
  // Reset chart for new symbol
  closedClusters = [];
  formingCluster = null;
  formingTicks = [];
  masterTicks = [];
  clusters = [];
  totalTicks = 0;
  lastPrice = 0;

  // Load symbol defaults (matching server SYM_CFG)
  const cfg = SYMBOLS[sym] || {};
  if (cfg.delta_th) {
    threshold = cfg.delta_th;
    document.getElementById('thresholdSlider').value = threshold;
    document.getElementById('thresholdValue').textContent = threshold >= 1000 ? (threshold/1000) + 'k' : threshold;
  }
  if (cfg.step !== undefined) {
    priceStep = cfg.step;
    document.getElementById('stepSlider').value = priceStep >= 1 ? priceStep : Math.round(priceStep * 10000);
    document.getElementById('stepValue').textContent = priceStep >= 1 ? '$' + priceStep.toFixed(0) : priceStep.toFixed(4);
  }
  
  // Update source label
  const el = document.getElementById('engineSourceLabel');
  if (el) el.textContent = (cfg.label || sym);

  render();
}

function setWeightMode(mode) {
  weightMode = mode;
  if (ws && ws.readyState === 1) {
    ws.send(JSON.stringify({ action: 'set_weight_mode', mode: mode }));
  }
}

function loadHistory(hours) {
  if (!ws || ws.readyState !== 1) return;
  document.getElementById('sourceLabel').textContent = 'carregando ' + hours + 'h...';
  ws.send(JSON.stringify({
    action: 'get_history',
    symbol: currentSymbol,
    hours: hours,
  }));
}

function resetChart() {
  closedClusters = [];
  formingCluster = null;
  formingTicks = [];
  masterTicks = [];
  clusters = [];
  totalTicks = 0;
  viewState.offsetX = 0;
  viewState.scaleX = 1;
  viewState.scaleY = 1;
  updateUI();
  render();
}

// ---------- UI UPDATES ----------
function updateUI() {
  // Price display
  const priceEl = document.getElementById('priceDisplay');
  const symDig = (SYMBOLS[currentSymbol] || {}).dig || 2;
  priceEl.textContent = lastPrice > 0 ? lastPrice.toFixed(symDig) : '--';
  priceEl.className = 'price-display ' + (lastSide === 'buy' ? 'up' : 'down');

  // Tick counter
  document.getElementById('tickCounter').textContent = totalTicks.toLocaleString() + ' ticks';

  // Cluster counter
  document.getElementById('clusterCount').textContent = clusters.filter(c => c.isClosed).length;

  // Forming cluster bar
  const forming = clusters.find(c => !c.isClosed);
  const bar = document.getElementById('formingBar');
  if (forming) {
    bar.classList.add('visible');
    const deltaEl = document.getElementById('formingDelta');
    deltaEl.textContent = (forming.delta >= 0 ? '+' : '') + forming.delta;
    deltaEl.style.color = forming.delta >= 0 ? CONFIG.bull : CONFIG.bear;

    document.getElementById('formingBody').textContent =
      forming.volumeTotal > 0 ? ((forming.volumeBody / forming.volumeTotal) * 100).toFixed(0) + '%' : '0%';
    document.getElementById('formingWick').textContent = forming.wickPercent.toFixed(0) + '%';

    // Absorption info
    const absEl = document.getElementById('formingAbsorptions');
    if (forming.absorptionCount > 0) {
      absEl.style.display = 'inline';
      absEl.textContent = `üß© ${forming.absorptionCount} abs (${forming.absorptionBuyCount}B / ${forming.absorptionSellCount}S)`;
    } else {
      absEl.style.display = 'none';
    }

    // Stacking info
    const stackEl = document.getElementById('formingStacking');
    if (forming.maxStackingBuy >= 2 || forming.maxStackingSell >= 2) {
      stackEl.style.display = 'inline';
      stackEl.style.color = forming.maxStackingBuy > forming.maxStackingSell ? CONFIG.absorptionBuy : CONFIG.absorptionSell;
      stackEl.style.fontWeight = '700';
      stackEl.textContent = `üî• Stack B${forming.maxStackingBuy}/S${forming.maxStackingSell}`;
    } else {
      stackEl.style.display = 'none';
    }

    // Delta progress bar
    const fill = document.getElementById('deltaBarFill');
    const pct = Math.min(100, (Math.abs(forming.delta) / threshold) * 100);
    fill.style.width = pct + '%';
    fill.style.background = forming.delta >= 0 ? CONFIG.bull : CONFIG.bear;
  } else {
    bar.classList.remove('visible');
  }
}

function updateEnginePanel() {
  const e = engineState;

  // Tick Velocity
  if (e.tick_velocity) {
    document.getElementById('eng_velocity').textContent = (e.tick_velocity.velocity || 0).toFixed(1) + ' t/s';
    document.getElementById('eng_velocity_base').textContent = (e.tick_velocity.baseline || 0).toFixed(1);
    const burst = document.getElementById('eng_burst');
    burst.style.display = e.tick_velocity.is_burst ? 'inline' : 'none';
  }

  // Micro Cluster / Absorption
  if (e.micro_cluster) {
    const absEl = document.getElementById('eng_absorption');
    if (e.micro_cluster.is_absorption) {
      const isBuy = e.micro_cluster.absorption_type === 'buy_absorption';
      absEl.textContent = isBuy ? 'üü¢ BUY ABS' : 'üî¥ SELL ABS';
      absEl.style.color = isBuy ? CONFIG.absorptionBuy : CONFIG.absorptionSell;
    } else {
      absEl.textContent = 'Sem absor√ß√£o';
      absEl.style.color = CONFIG.text;
    }
    document.getElementById('eng_abs_total').textContent = e.micro_cluster.total_absorptions || 0;
  }

  // ATR
  if (e.atr_normalize) {
    const atr = e.atr_normalize.atr;
    document.getElementById('eng_atr').textContent = atr ? (atr * 100).toFixed(4) : '--';
    const regimeEl = document.getElementById('eng_atr_regime');
    regimeEl.textContent = e.atr_normalize.regime || 'warmup';
    regimeEl.style.color =
      e.atr_normalize.regime === 'expanding' ? CONFIG.absorptionSell :
      e.atr_normalize.regime === 'contracting' ? CONFIG.absorptionBuy : CONFIG.text;
  }

  // Imbalance Stacking
  if (e.imbalance_detector) {
    document.getElementById('eng_stack_buy').textContent = 'Buy: S' + (e.imbalance_detector.stacking_buy || 0);
    document.getElementById('eng_stack_sell').textContent = 'Sell: S' + (e.imbalance_detector.stacking_sell || 0);
    const dom = document.getElementById('eng_dominant');
    if (e.imbalance_detector.dominant_direction) {
      dom.textContent = '‚Üí ' + e.imbalance_detector.dominant_direction.toUpperCase();
      dom.style.color = e.imbalance_detector.dominant_direction === 'buy' ? CONFIG.absorptionBuy : CONFIG.absorptionSell;
    } else {
      dom.textContent = '';
    }
  }

  // Spread / Volatility
  if (e.spread_weight) {
    document.getElementById('eng_vol').textContent = (e.spread_weight.volatility || 0).toFixed(2) + ' bps';
    const regEl = document.getElementById('eng_vol_regime');
    regEl.textContent = e.spread_weight.regime || '--';
    regEl.style.color =
      e.spread_weight.regime === 'high' ? CONFIG.absorptionSell :
      e.spread_weight.regime === 'low' ? CONFIG.absorptionBuy : CONFIG.text;
  }

  // Composite Signal
  const signal = e.micro_cluster?.signal || 0;
  const sigEl = document.getElementById('eng_signal');
  sigEl.textContent = (signal * 100).toFixed(0) + '%';
  sigEl.style.color = signal > 0.2 ? CONFIG.absorptionBuy : signal < -0.2 ? CONFIG.absorptionSell : CONFIG.text;
  const labEl = document.getElementById('eng_signal_label');
  labEl.textContent = signal > 0 ? 'bullish' : signal < 0 ? 'bearish' : 'neutro';
}

// ---------- START ----------
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>